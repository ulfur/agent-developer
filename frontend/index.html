<!doctype html>
<html lang="en" data-theme="dark">
  <head>
    <meta charset="utf-8" />
    <title>Nightshift</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="icon"
      href="./nightshift-favicon-dark.png"
      type="image/png"
      sizes="256x256"
      data-nightshift-favicon="png"
    />
    <link
      rel="alternate icon"
      href="./nightshift-favicon-dark.ico"
      type="image/x-icon"
      data-nightshift-favicon="ico"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@7.4.47/css/materialdesignicons.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/vuetify@3.7.4/dist/vuetify.min.css" />
    <style>
      :root {
        --app-bg: #f3f4f6;
        --app-surface: #ffffff;
        --card-border: #d7dce3;
        --text-primary: #1f2933;
        --text-muted: #5d6675;
        --prompt-bubble-bg: #ffffff;
        --response-bubble-bg: #f8fafc;
        --response-text: #111827;
        --stream-bg: #f5f7fb;
        --stream-border: #c8ceda;
        --stderr-bg: #f1f5f9;
        --detail-summary-bg: #eceff5;
        --detail-panel-border: var(--stream-border);
        --detail-panel-open-bg: var(--app-surface);
        --divider-color: #d7dce3;
        --prompt-sticky-offset: 96px;
        --stdout-bg: var(--app-surface);
        --stdout-text: var(--text-primary);
      }

      :root[data-theme="dark"] {
        --app-bg: #0e1117;
        --app-surface: #161b22;
        --card-border: rgba(148, 163, 184, 0.35);
        --text-primary: #e5e7eb;
        --text-muted: #9ca3af;
        --prompt-bubble-bg: #232c3d;
        --response-bubble-bg: #162034;
        --response-text: #f8fafc;
        --stream-bg: rgba(31, 41, 55, 0.85);
        --stream-border: rgba(148, 163, 184, 0.3);
        --stderr-bg: rgba(148, 163, 184, 0.18);
        --detail-summary-bg: rgba(148, 163, 184, 0.35);
        --detail-panel-border: rgba(148, 163, 184, 0.45);
        --detail-panel-open-bg: rgba(255, 255, 255, 0.08);
        --divider-color: rgba(148, 163, 184, 0.35);
        --prompt-sticky-offset: 96px;
        --stdout-bg: #1e2430;
        --stdout-text: #f3f4f6;
      }

      @media (max-width: 640px) {
        :root,
        :root[data-theme="dark"] {
          --prompt-sticky-offset: 72px;
        }
      }

      html,
      body,
      #app {
        min-height: 100%;
        margin: 0;
        font-family: 'Roboto', sans-serif;
        background-color: var(--app-bg);
        color: var(--text-primary);
      }

      body {
        overflow-y: auto;
        overflow-x: hidden;
      }

      .v-application,
      .v-layout {
        min-height: 100%;
      }

      .v-main {
        background-color: var(--app-bg);
        min-height: calc(100vh - var(--v-layout-top, 64px));
        padding-top: var(--v-layout-top, 64px);
        box-sizing: border-box;
      }

      .main-layout {
        display: flex;
        flex-direction: column;
        box-sizing: border-box;
        min-height: calc(100vh - var(--v-layout-top, 64px));
      }

      @media (min-width: 960px) {
        .main-layout {
          height: calc(100vh - var(--v-layout-top, 64px));
        }
      }
      @media (min-width: 960px) {
        .main-layout--settings {
          height: auto;
        }
      }

      .main-row {
        flex: 1;
        min-height: 0;
        height: 100%;
        display: flex;
        flex-wrap: wrap;
        align-content: stretch;
        align-items: stretch;
        overflow: hidden;
      }

      .settings-row {
        flex: 1;
        min-height: 0;
        display: flex;
        flex-wrap: wrap;
        align-content: stretch;
        align-items: stretch;
      }
      .settings-log-row {
        flex: 0 0 auto;
        width: 100%;
      }

      .main-row > .v-col {
        display: flex;
        flex-direction: column;
        min-height: 0;
        height: 100%;
        box-sizing: border-box;
        max-width: 100%;
        overflow: hidden;
      }

      .settings-row > .v-col {
        display: flex;
        flex-direction: column;
        min-height: 0;
      }

      @media (min-width: 960px) {
        .main-row {
          flex-wrap: nowrap;
        }
        .main-row > .v-col {
          max-height: 100%;
        }
        .settings-row {
          flex-wrap: nowrap;
        }
      }

      .panel-card {
        border: 1px solid var(--card-border);
        border-radius: 16px;
        background-color: var(--app-surface);
        max-width: 100%;
      }

      .queue-card,
      .chat-card {
        display: flex;
        flex-direction: column;
        flex: 1 1 auto;
        max-height: 100%;
        min-height: 0;
        overflow: hidden;
      }

      .chat-card__header {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 0.75rem;
        flex-wrap: nowrap;
        min-height: 56px;
      }

      .chat-card__header-main {
        flex: 1 1 auto;
        min-width: 0;
      }

      .chat-card__header .thread-header__actions {
        flex: 0 0 auto;
      }

      .chat-card-human-task {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        font-size: 0.85rem;
        color: var(--text-muted);
        margin-top: 0.35rem;
      }

      .chat-card-human-task .mdi {
        font-size: 1rem;
      }

      .mobile-panel-controls {
        display: none;
      }

      @media (max-width: 959px) {
        .chat-card__header {
          flex-direction: column;
          align-items: flex-start;
          gap: 0.5rem;
        }

        .chat-card__header .thread-header__actions {
          width: 100%;
          justify-content: flex-start;
        }

        .chat-card-title__heading {
          flex-direction: column;
          align-items: flex-start;
          gap: 0.4rem;
        }

        .mobile-panel-controls {
          display: flex;
          width: 100%;
          justify-content: flex-end;
          padding: 0.5rem 1.5rem 0;
        }

        .mobile-panel-controls .v-btn {
          text-transform: none;
        }
      }

      .log-card {
        display: flex;
        flex-direction: column;
        max-width: 100%;
      }

      .settings-log-card {
        height: 100%;
        display: flex;
        flex-direction: column;
        min-height: 0;
        overflow: hidden;
      }

      @media (min-width: 960px) {
        .settings-log-card {
          max-height: calc(100vh - var(--v-layout-top, 64px) - 96px);
        }
      }

      .settings-log-card .log-card__body {
        flex: 1 1 auto;
        display: flex;
        flex-direction: column;
        min-height: 0;
      }

      .settings-log-card .log-content {
        flex: 1 1 auto;
        min-height: 0;
        height: 100%;
        max-height: none;
      }

      .log-card__header {
        display: flex;
        justify-content: space-between;
        gap: 1rem;
        align-items: flex-start;
      }

      .log-card__actions {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .log-card__body {
        min-height: 220px;
      }

      .log-content {
        background-color: var(--stream-bg);
        border: 1px solid var(--stream-border);
        border-radius: 12px;
        padding: 0.75rem 1rem;
        font-family: 'Roboto Mono', 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        font-size: 0.85rem;
        line-height: 1.45;
        white-space: pre-wrap;
        word-break: break-word;
        max-height: 260px;
        overflow-y: auto;
      }

      .log-content pre {
        margin: 0;
      }

      .log-content--empty {
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--text-muted);
        font-style: italic;
      }

      .ssh-key-list {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .ssh-key-item {
        border: 1px solid var(--card-border);
        border-radius: 12px;
        padding: 0.75rem 1rem;
        background-color: var(--prompt-bubble-bg);
      }

      .ssh-key-header {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
      }

      .ssh-key-text {
        font-family: 'Roboto Mono', 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        font-size: 0.85rem;
        margin: 0;
        white-space: pre-wrap;
        word-break: break-word;
      }

      .log-content__placeholder {
        color: var(--text-muted);
      }

      .realtime-chip {
        text-transform: none;
        font-weight: 600;
      }

      .queue-scroll {
        flex: 1 1 auto;
        min-height: 0;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
        padding: 1.25rem 1.5rem;
      }

      .human-tasks-panel {
        padding: 1.25rem 1.5rem 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
      }

      .human-tasks-panel__header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .human-tasks-panel__header-title {
        font-weight: 600;
        font-size: 1rem;
      }

      .human-tasks-panel__badges {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        align-items: center;
      }

      .human-tasks-panel__body {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .human-tasks-list {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        max-height: 260px;
        overflow-y: auto;
      }

      .human-task-entry {
        border: 1px solid var(--card-border);
        border-radius: 12px;
        padding: 0.85rem 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        background-color: var(--app-surface);
      }

      .human-task-entry__header {
        display: flex;
        justify-content: space-between;
        gap: 0.5rem;
        align-items: center;
        font-weight: 600;
      }

      .human-task-entry__header-actions {
        display: flex;
        align-items: center;
        gap: 0.35rem;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .human-task-entry__meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        font-size: 0.85rem;
        color: var(--text-muted);
      }

      .human-task-entry__description {
        margin: 0;
        font-size: 0.9rem;
        color: var(--text-primary);
      }

      .human-task-entry__description-toggle {
        border: none;
        background: none;
        color: #2563eb;
        cursor: pointer;
        font: inherit;
        font-size: 0.8rem;
        font-weight: 500;
        margin-left: 0.35rem;
        padding: 0;
      }

      .human-task-entry__description-toggle:hover,
      .human-task-entry__description-toggle:focus-visible {
        text-decoration: underline;
      }

      .human-task-entry__description-toggle:focus-visible {
        outline: 2px solid rgba(37, 99, 235, 0.35);
        outline-offset: 2px;
      }

      .human-task-entry__clear-btn,
      .human-task-entry__reply-btn {
        min-width: 32px;
        width: 32px;
        height: 32px;
      }

      .human-tasks-panel__empty {
        text-align: center;
        font-size: 0.9rem;
        color: var(--text-muted);
        padding: 0.75rem 0;
      }

      .human-tasks-panel__footer {
        font-size: 0.8rem;
        color: var(--text-muted);
      }

      .queue-list {
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
      }

      .queue-entry {
        border: 1px solid var(--card-border);
        border-radius: 12px;
        background-color: var(--app-surface);
        padding: 0.85rem 1rem;
        text-align: left;
        cursor: pointer;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        font: inherit;
      }

      .queue-entry:hover,
      .queue-entry:focus-visible {
        border-color: var(--text-muted);
        box-shadow: 0 4px 12px rgba(15, 23, 42, 0.08);
        outline: none;
      }

      .queue-entry.active {
        border-color: rgba(37, 99, 235, 0.65);
        box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.35);
      }

      .queue-entry-header {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem 1rem;
        align-items: center;
        font-family: 'Roboto Mono', 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        font-size: 0.85rem;
      }

      .queue-entry-index {
        font-weight: 600;
      }

      .queue-entry-status {
        text-transform: uppercase;
        letter-spacing: 0.08em;
        font-weight: 600;
      }

      .queue-entry-status.status-completed {
        color: #22c55e;
      }

      .queue-entry-status.status-failed {
        color: #f87171;
      }

      .queue-entry-status.status-running {
        color: #facc15;
      }

      .queue-entry-status.status-queued {
        color: #60a5fa;
      }

      .queue-entry-status.status-canceled {
        color: #f97316;
      }

      .queue-entry-detail {
        color: var(--text-muted);
        font-size: 0.9rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .queue-entry-human-task {
        margin-top: 0.35rem;
        display: flex;
        align-items: center;
        gap: 0.35rem;
        font-size: 0.82rem;
        color: var(--text-muted);
      }

      .queue-entry-human-task .mdi {
        font-size: 0.95rem;
      }

      @media (max-width: 959px) {
        .queue-card {
          max-height: min(75vh, 640px);
          flex: 0 0 auto;
        }

        .queue-entry-detail {
          white-space: normal;
          display: -webkit-box;
          -webkit-box-orient: vertical;
          -webkit-line-clamp: 2;
          line-clamp: 2;
          word-break: break-word;
        }
      }


      .chat-thread {
        flex: 1;
        min-height: 0;
        padding: 1.25rem 1.5rem;
        overflow-y: auto;
        max-height: 100%;
        display: flex;
        flex-direction: column;
        gap: 1.25rem;
        position: relative;
        scroll-padding-top: calc(var(--prompt-sticky-offset) + 1.5rem);
      }

      .attempt-entry {
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
      }

      .chat-message {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        max-width: 85%;
      }

      .chat-message.user {
        align-self: flex-end;
      }

      .chat-message.codex {
        align-self: flex-start;
      }

      .chat-bubble {
        border-radius: 16px;
        padding: 1.25rem;
        border: 1px solid var(--card-border);
        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.08);
        position: relative;
      }

      .chat-bubble.copyable {
        padding-right: 3.25rem;
      }

      .chat-bubble.prompt {
        background-color: var(--prompt-bubble-bg);
        color: var(--text-primary);
      }

      .chat-thread .chat-bubble.prompt {
        position: sticky;
        top: var(--prompt-sticky-offset);
        z-index: 5;
      }

      .chat-bubble.response {
        background-color: var(--response-bubble-bg);
        color: var(--response-text);
        max-height: none;
        overflow: visible;
      }

      .stdout-block,
      .stderr-block,
      .context-block {
        margin-top: 0.75rem;
        padding: 0.85rem;
        border-radius: 12px;
        background-color: var(--stream-bg);
        border: 1px solid var(--stream-border);
        white-space: pre-wrap;
        font-family: 'Roboto Mono', 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        font-size: 0.92rem;
        line-height: 1.5;
      }

      .stdout-block {
        color: var(--stdout-text);
        background-color: var(--stdout-bg);
        max-height: min(75vh, 520px);
        overflow-y: auto;
      }

      .stderr-block {
        background-color: var(--stderr-bg);
        color: inherit;
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
        max-height: min(50vh, 520px);
        overflow: scroll;
      }

      .stderr-segment {
        white-space: inherit;
        word-break: break-word;
      }

      .stderr-code-block,
      .stderr-exec-block {
        border: 1px dashed var(--stream-border);
        border-radius: 10px;
        padding: 0.35rem 0.65rem 0.65rem;
        background-color: rgba(15, 23, 42, 0.04);
      }

      :root[data-theme='dark'] .stderr-code-block,
      :root[data-theme='dark'] .stderr-exec-block {
        background-color: rgba(255, 255, 255, 0.04);
      }

      .stderr-code-block summary,
      .stderr-exec-block summary {
        cursor: pointer;
        list-style: none;
        font-size: 0.85rem;
        color: var(--text-muted);
        display: flex;
        align-items: center;
        gap: 0.4rem;
      }

      .stderr-code-block summary::-webkit-details-marker,
      .stderr-exec-block summary::-webkit-details-marker {
        display: none;
      }

      .stderr-code-summary {
        width: 100%;
        text-overflow: ellipsis;
        white-space: nowrap;
        overflow: hidden;
      }

      .stderr-code-summary__label {
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        font-size: 0.75rem;
      }

      .stderr-code-content {
        margin-top: 0.5rem;
        padding: 0.65rem;
        border-radius: 8px;
        background-color: rgba(15, 23, 42, 0.04);
        color: inherit;
        white-space: pre-wrap;
        overflow-x: auto;
      }

      :root[data-theme='dark'] .stderr-code-content {
        background-color: rgba(255, 255, 255, 0.04);
      }

      .context-block {
        color: var(--text-primary);
      }

      .detail-footer {
        border-top: 1px solid var(--divider-color);
        padding: 0.75rem 1.5rem 1.25rem;
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
        font-size: 0.85rem;
        color: var(--text-muted);
        flex-shrink: 0;
      }

      .queue-composer {
        padding: 1rem 1.5rem 1.25rem;
        background-color: var(--app-surface);
        flex-shrink: 0;
      }

      .queue-composer--mobile {
        padding: 0.75rem 1rem 1rem;
      }

      .queue-composer--mobile-collapsed {
        padding-bottom: 0.75rem;
      }

      .mobile-composer-toggle {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
      }

      .mobile-composer-toggle__text {
        flex: 1;
        min-width: 0;
      }

      .mobile-composer-toggle__title {
        font-weight: 600;
        font-size: 0.95rem;
        margin-bottom: 0.1rem;
      }

      .mobile-composer-toggle__hint {
        font-size: 0.8rem;
        color: var(--text-muted);
      }

      .mobile-composer-toggle__button {
        flex-shrink: 0;
      }

      .queue-composer__body {
        margin-top: 0.75rem;
      }

      .queue-composer:not(.queue-composer--mobile) .queue-composer__body {
        margin-top: 0;
      }

      .human-task-reply-banner {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.45rem 0.75rem;
        border-radius: 8px;
        border: 1px solid var(--detail-panel-border);
        background-color: rgba(103, 80, 164, 0.08);
        color: var(--text-primary);
        margin-bottom: 0.75rem;
      }

      .human-task-reply-banner__icon {
        font-size: 1rem;
        color: var(--primary-color, #6750a4);
      }

      .human-task-reply-banner__text {
        flex: 1;
        font-size: 0.9rem;
      }

      .human-task-reply-banner__text strong {
        font-weight: 600;
      }

      .human-task-reply-banner__clear {
        flex-shrink: 0;
      }

      .codex-status {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }

      .codex-status__line {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
      }

      .codex-status__value {
        font-weight: 600;
        color: var(--text-primary);
      }

      .codex-status__error {
        color: var(--v-theme-error, #de3730);
        font-weight: 500;
      }

      .composer-actions {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 0.75rem;
        gap: 1rem;
      }

      .detail-panel {
        margin-top: 0.8rem;
        border-radius: 12px;
        border: 1px solid var(--detail-panel-border);
        background-color: var(--detail-summary-bg);
        padding: 0.45rem 0.85rem;
      }

      .detail-panel summary {
        cursor: pointer;
        list-style: none;
        font-weight: 500;
        color: var(--text-muted);
        display: flex;
        align-items: center;
        gap: 0.4rem;
      }

      .detail-panel summary .copy-button {
        margin-left: auto;
      }

      .detail-panel summary::marker {
        display: none;
      }

      .detail-panel summary::-webkit-details-marker {
        display: none;
      }

      .detail-panel[open] {
        background-color: var(--detail-panel-open-bg);
      }

      .detail-panel .detail-content {
        margin-top: 0.75rem;
      }

      .message-meta {
        display: flex;
        gap: 0.85rem;
        flex-wrap: wrap;
        font-size: 0.8rem;
        color: var(--text-muted);
      }

      .message-meta--header {
        padding-inline: 0.25rem;
      }

      .chat-bubble .message-meta {
        margin-bottom: 0.75rem;
      }

      .prompt-text {
        white-space: pre-wrap;
        line-height: 1.6;
      }

      .copy-button {
        border: none;
        background: transparent;
        color: var(--text-muted);
        cursor: pointer;
        border-radius: 999px;
        padding: 0.15rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: color 0.2s ease, background-color 0.2s ease;
      }

      .copy-button:hover,
      .copy-button:focus-visible {
        color: var(--text-primary);
        background-color: rgba(148, 163, 184, 0.2);
        outline: none;
      }

      .copy-button .mdi {
        font-size: 1rem;
      }

      .copy-button--floating {
        position: absolute;
        top: 0.75rem;
        right: 0.75rem;
      }

      .prompt-bubble-actions {
        position: absolute;
        top: 0.65rem;
        right: 0.65rem;
        display: flex;
        flex-direction: column;
        gap: 0;
        align-items: flex-end;
      }

      .prompt-bubble-actions .copy-button {
        padding: 0.05rem 0.3rem;
        line-height: 1;
      }

      .prompt-edit-button .mdi {
        font-size: 1rem;
      }

      .thread-header__actions {
        margin-left: auto;
        display: flex;
        flex-wrap: wrap;
        justify-content: flex-end;
        align-items: center;
        gap: 0.5rem;
      }

      .stdout-empty {
        opacity: 0.7;
        font-style: italic;
      }

      .global-header {
        background-color: var(--app-surface);
        border-bottom: 1px solid var(--card-border);
        padding-inline-end: 1.25rem;
      }

      .global-header__branding {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .global-header__home-link {
        font: inherit;
        color: inherit;
        background: transparent;
        border: none;
        padding: 0;
        margin: 0;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 0.6rem;
        text-decoration: none;
      }

      .global-header__text {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        line-height: 1.2;
        text-align: right;
      }

      .global-header__home-link:focus-visible {
        outline: 2px solid var(--card-border);
        outline-offset: 2px;
        border-radius: 6px;
      }

      .global-header__logo {
        width: 36px;
        height: 36px;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        flex-shrink: 0;
      }

      html[data-theme='light'] .global-header__logo {
        box-shadow: none;
      }

      .global-header__title {
        font-size: 1.35rem;
        font-weight: 600;
        letter-spacing: 0.01em;
      }

      .global-header__subtitle {
        font-size: 0.6rem;
        font-weight: 300;
        font-style: italic;
        color: var(--text-muted);
        letter-spacing: 0.08em;
      }

      @media (max-width: 959px) {
        .global-header__title {
          display: none;
        }

        .global-header__subtitle {
          display: none;
        }

        .global-header .guided-tour-trigger {
          display: none;
        }
      }

      .header-notifications {
        display: flex;
        align-items: center;
        margin-inline-end: 0.5rem;
      }

      .human-tasks-trigger {
        width: 44px;
        height: 44px;
        border-radius: 999px;
        justify-content: center;
      }

      .human-tasks-trigger__icon {
        font-size: 1.3rem;
      }

      .human-tasks-dropdown {
        width: min(420px, calc(100vw - 32px));
        border-radius: 20px;
        overflow: hidden;
      }

      .human-tasks-dropdown__footer {
        font-size: 0.85rem;
        color: var(--text-muted);
      }

      .theme-toggle {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: space-between;
        width: 88px;
        height: 36px;
        padding: 0 14px;
        border-radius: 999px;
        border: none;
        background-color: var(--app-surface);
        box-shadow: inset 0 0 0 1px var(--card-border);
        cursor: pointer;
        transition: background-color 0.2s ease, border-color 0.2s ease;
        gap: 10px;
        appearance: none;
        font: inherit;
        color: inherit;
      }

      .theme-toggle:focus-visible {
        outline: 2px solid var(--card-border);
        outline-offset: 2px;
      }

      .theme-toggle__icon {
        font-size: 16px;
        color: var(--text-muted);
        pointer-events: none;
      }

      .theme-toggle__thumb {
        position: absolute;
        top: 3px;
        left: 4px;
        width: 38px;
        height: 30px;
        border-radius: 999px;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: var(--app-bg);
        box-shadow: 0 4px 12px rgba(15, 23, 42, 0.25);
        transition: transform 0.25s ease, background-color 0.2s ease;
      }

      .theme-toggle__thumb--right {
        transform: translateX(36px);
      }

      .theme-toggle__thumb .mdi {
        font-size: 18px;
        color: var(--text-primary);
      }

      .header-theme-toggle {
        margin-right: 1rem;
      }

      .queue-card-title {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        min-height: 56px;
      }

      .queue-card-title span:first-child {
        font-size: 1rem;
        font-weight: 500;
      }

      .header-menus {
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }

      .user-menu__activator {
        text-transform: none;
        display: flex;
        align-items: center;
        gap: 0.35rem;
        color: var(--text-primary) !important;
        font-weight: 600;
      }

      .user-menu__activator .mdi {
        font-size: 18px;
      }

      .workspace-selector {
        padding: 1rem 1.5rem 0.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .workspace-selector__hint {
        font-size: 0.85rem;
        color: var(--text-muted);
      }

      .workspace-selector__live-link {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        font-weight: 500;
        color: var(--text-primary);
        text-decoration: none;
      }

      .workspace-selector__live-link .mdi {
        font-size: 1rem;
        opacity: 0.8;
      }

      .workspace-selector__live-link:focus-visible {
        outline: 2px solid rgba(96, 165, 250, 0.5);
        outline-offset: 2px;
      }

      .workspace-selector__live-link--disabled {
        color: var(--text-muted);
        cursor: default;
      }

      .prompt-workspace-pill {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        padding: 0.1rem 0.5rem;
        border-radius: 999px;
        border: 1px solid rgba(59, 130, 246, 0.4);
        font-size: 0.55rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: #60a5fa;
      }

      .chat-card-title__heading {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.35rem;
        font-size: 1rem;
        font-weight: 500;
        width: 100%;
      }

      .chat-card-title__task {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        flex-wrap: wrap;
      }

      .chat-card-title__cancel,
      .chat-card-title__delete {
        flex-shrink: 0;
      }

      @media (max-width: 640px) {
        .chat-card-title__task {
          width: 100%;
        }

        .chat-card-title__cancel {
          margin-left: auto;
        }
      }

      .chat-card-subtitle {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .chat-card-subtitle__attempts {
        margin-right: auto;
      }

      .task-id-button {
        border: none;
        background: none;
        color: inherit;
        font: inherit;
        padding: 0;
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        cursor: pointer;
      }

      .task-id-button .mdi {
        font-size: 0.95rem;
      }

      .task-id-button:focus-visible {
        outline: 2px solid #60a5fa;
        outline-offset: 2px;
        border-radius: 6px;
      }

      .login-container {
        min-height: calc(100vh - var(--v-layout-top, 64px));
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem 1rem;
      }

      .login-wrapper {
        width: 100%;
        max-width: 420px;
      }

      .login-card {
        padding-bottom: 1rem;
      }

      .user-summary {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        font-size: 0.9rem;
        color: var(--text-muted);
      }

      .user-summary__email {
        font-weight: 600;
      }

      .user-menu-card {
        min-width: 250px;
        padding: 0.25rem 0;
      }

      .user-menu-icon {
        margin-right: 0.4rem;
        font-size: 18px;
      }

      .logout-theme-toggle {
        margin-left: 0.75rem;
      }

      .logout-list-item {
        text-transform: none;
      }

      .guided-tour-trigger {
        text-transform: none;
        font-weight: 600;
        font-size: 0.6rem;
        padding: 0.02rem 0.35rem;
        min-height: 20px;
        border-radius: 999px;
        align-self: center;
        letter-spacing: 0.02em;
      }

      .guided-tour-trigger .v-btn__prepend {
        margin-right: 0.25rem;
      }

      .guided-tour-trigger .v-btn__prepend .v-icon {
        font-size: 0.85rem;
      }

      .guided-tour-overlay {
        position: fixed;
        inset: 0;
        z-index: 4000;
        pointer-events: none;
      }

      .guided-tour-highlight {
        position: fixed;
        border-radius: 18px;
        border: 2px solid rgba(96, 165, 250, 0.95);
        box-shadow:
          0 20px 60px rgba(15, 23, 42, 0.35),
          0 0 0 9999px rgba(8, 15, 33, 0.75);
        transition: all 0.2s ease;
        pointer-events: none;
      }

      .guided-tour-tooltip {
        position: fixed;
        left: 50%;
        bottom: 32px;
        transform: translateX(-50%);
        max-width: min(520px, calc(100vw - 32px));
        background: var(--app-surface);
        color: var(--text-primary);
        border-radius: 16px;
        border: 1px solid var(--card-border);
        padding: 1.25rem 1.5rem;
        box-shadow: 0 20px 45px rgba(15, 23, 42, 0.3);
        pointer-events: auto;
      }

      .guided-tour-step-label {
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--text-muted);
        margin-bottom: 0.35rem;
        display: block;
      }

      .guided-tour-tooltip h3 {
        margin: 0;
        font-size: 1.1rem;
      }

      .guided-tour-tooltip p {
        margin: 0.35rem 0 0;
        line-height: 1.5;
      }

      .guided-tour-missing {
        font-size: 0.9rem;
        color: #fbbf24;
      }

      .guided-tour-actions {
        margin-top: 1rem;
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }

      .guided-tour-actions__spacer {
        flex: 1;
      }

      .guided-tour-link {
        background: transparent;
        border: none;
        padding: 0;
        font: inherit;
        color: #93c5fd;
        cursor: pointer;
        text-decoration: underline;
      }

      .guided-tour-link:focus-visible {
        outline: 2px solid rgba(96, 165, 250, 0.5);
        outline-offset: 2px;
      }

      .guided-tour-button {
        border-radius: 999px;
        border: 1px solid var(--card-border);
        background: transparent;
        color: var(--text-primary);
        font: inherit;
        padding: 0.35rem 1.25rem;
        cursor: pointer;
        transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
      }

      .guided-tour-button:focus-visible {
        outline: 2px solid rgba(96, 165, 250, 0.5);
        outline-offset: 2px;
      }

      .guided-tour-button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .guided-tour-button--primary {
        background-color: #2563eb;
        border-color: #2563eb;
        color: #ffffff;
      }

      .overview-row {
        margin-bottom: 1.5rem;
      }

      .overview-card__title {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: flex-start;
      }

      .overview-card__title .overview-search {
        min-width: 220px;
        flex: 1 1 220px;
        max-width: 320px;
      }

      .workspace-column {
        overflow: visible !important;
      }

      .workspace-panel {
        position: sticky;
        top: var(--prompt-sticky-offset);
        display: flex;
        flex-direction: column;
        max-height: calc(100vh - var(--prompt-sticky-offset) - 2rem);
      }

      .workspace-panel__title {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: flex-start;
      }

      .workspace-panel__title .workspace-panel__summary {
        margin-top: 0.15rem;
      }

      .workspace-panel__actions {
        display: flex;
        gap: 0.35rem;
        align-items: center;
        margin-left: auto;
      }

      .workspace-panel__body {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        flex: 1;
        min-height: 0;
      }

      .workspace-panel--collapsed .workspace-panel__body {
        display: none;
      }

      .workspace-panel__section {
        flex: 1;
        min-height: 0;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .workspace-panel__section-header {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: flex-start;
      }

      .workspace-panel__content {
        flex: 1;
        min-height: 0;
        overflow-y: auto;
        padding-right: 0.35rem;
      }

      .workspace-panel--settings .mobile-panel-controls {
        padding: 1rem 1.5rem 0;
      }

      .workspace-panel--settings .workspace-panel__body {
        padding: 1rem 1.5rem 1.5rem;
      }

      .workspace-panel__footer {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
      }

      .workspace-panel__summary {
        font-size: 0.85rem;
        color: var(--text-muted);
      }

      @media (max-width: 959px) {
        .workspace-panel {
          position: static;
          max-height: none;
        }
        .workspace-panel__content {
          max-height: none;
          padding-right: 0;
        }
      }

      .workspace-directory {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        padding: 0;
      }

      .workspace-directory__item {
        border: 1px solid var(--card-border);
        border-radius: 12px;
        padding: 0.9rem;
        background-color: var(--prompt-bubble-bg);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .workspace-directory__header {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: flex-start;
      }

      .workspace-directory__name {
        font-weight: 600;
        font-size: 1rem;
      }

      .workspace-directory__description {
        font-size: 0.9rem;
        color: var(--text-muted);
        margin-top: 0.15rem;
        max-width: 520px;
      }

      .workspace-directory__actions {
        display: flex;
        gap: 0.4rem;
        flex-wrap: wrap;
        margin-left: auto;
        align-items: center;
      }

      .workspace-directory__meta {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 0.5rem;
        font-size: 0.85rem;
      }

      .workspace-directory__meta-item {
        display: flex;
        flex-direction: column;
        gap: 0.15rem;
      }

      .workspace-directory__meta-item span:first-child {
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--text-muted);
      }

      .workspace-directory__environments {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .workspace-directory__footer {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
      }

      .workspace-directory__footer .v-btn {
        padding-left: 0;
      }

      .workspace-environment-list {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .workspace-environment {
        border: 1px solid var(--card-border);
        border-radius: 12px;
        padding: 0.85rem;
        background-color: var(--app-bg);
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
      }

      .workspace-environment__header {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        gap: 0.5rem;
      }

      .workspace-environment__name {
        font-weight: 600;
      }

      .workspace-environment__subline {
        font-size: 0.85rem;
        color: var(--text-muted);
      }

      .workspace-environment__badges {
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem;
      }

      .workspace-environment__links {
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem;
      }

      .workspace-environment__actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
      }

      .workspace-environment__empty {
        color: var(--text-muted);
      }

    </style>
  </head>
  <body>
    <div id="app"></div>

    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://unpkg.com/vue-router@4/dist/vue-router.global.prod.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuetify@3.7.4/dist/vuetify.min.js"></script>
    <script>
      const { createApp, ref, reactive, computed, onMounted, onUnmounted, watch, nextTick } = Vue;
      const { createVuetify, useTheme } = Vuetify;
      const { createRouter, createWebHashHistory, useRoute, useRouter } = VueRouter;
      const THEME_STORAGE_KEY = 'codex-theme-mode';
      const AUTH_TOKEN_KEY = 'codex-auth-token';
      const PROJECT_STORAGE_KEY = 'codex-active-project';
      const WORKSPACE_PANEL_STORAGE_KEY = 'codex-workspace-panel-collapsed';
      const QUEUE_DETAIL_MAX = 160;
      const QUEUE_DETAIL_MOBILE_MAX = 96;
      const WS_RECONNECT_MIN_MS = 1000;
      const WS_RECONNECT_MAX_MS = 10000;
      const LOG_REFRESH_INTERVAL_MS = 30000;
      const HUMAN_TASK_DESCRIPTION_PREVIEW_LIMIT = 220;
      const MOBILE_BREAKPOINT = 960;
      const GUIDED_TOUR_PADDING = 16;
      const GUIDED_TOUR_FLOWS = {
        queue: [
          {
            id: 'welcome',
            target: '[data-tour-id=\"tour-home-link\"]',
            title: 'Welcome to Nightshift',
            description:
              'Start from the main dashboard — the logo brings you home and the profile menu on the right hops over to Settings whenever you need to adjust Nightshift.',
          },
          {
            id: 'user-menu',
            target: '[data-tour-id=\"tour-user-menu\"]',
            title: 'Jump into Settings',
            description:
              'Open this menu to review your account or sign out. Use it to switch to the Settings page, then return via the Nightshift logo.',
          },
          {
            id: 'project-focus',
            target: '[data-tour-id=\"tour-workspace-selector\"]',
            title: 'Focus Nightshift on the right workspace',
            description: 'Pick which workspace Nightshift should care about. This choice scopes prompts, context, and launch links.',
          },
          {
            id: 'prompt-composer',
            target: '[data-tour-id=\"tour-prompt-composer\"]',
            title: 'Compose a new instruction',
            description: 'Type what you want Nightshift to do, then press Send. Average turn duration helps you know how long you might wait.',
          },
          {
            id: 'prompt-queue',
            target: '[data-tour-id=\"tour-queue-list\"]',
            title: 'Track the Task queue',
            description: 'Each entry shows status, timing, and a quick summary so you can jump into any task while it runs.',
          },
          {
            id: 'human-task-queue',
            target: '[data-tour-id=\"tour-human-tasks\"]',
            title: 'Spot blockers fast',
            description: 'Human Tasks capture anything that needs an operator. Watch the notification badge and open the dropdown to review blockers where the agent asks the operator for assistance.',
          },
          {
            id: 'prompt-thread',
            target: '[data-tour-id=\"tour-thread-panel\"]',
            title: 'Review Nightshift output',
            description: 'The thread view holds your prompt, live stdout/stderr, and prior attempts—plus controls to edit, cancel, or retry.',
          },
        ],
        settings: [
          {
            id: 'settings-navigation',
            target: '[data-tour-id=\"tour-home-link\"]',
            title: 'Head back to the dashboard',
            description: 'The Nightshift logo always returns you to the Task Queue once you finish making changes here.',
          },
          {
            id: 'settings-password',
            target: '[data-tour-id=\"tour-settings-password\"]',
            title: 'Update your password',
            description: 'Keep your account secure by filling in the current and new passwords, then submit when you are ready.',
          },
          {
            id: 'settings-ssh',
            target: '[data-tour-id=\"tour-settings-ssh\"]',
            title: 'Manage SSH keys',
            description: 'Refresh and copy the public SSH keys that you add to GitHub or any git host when linking Nightshift.',
          },
          {
            id: 'settings-log',
            target: '[data-tour-id=\"tour-operations-log\"]',
            title: 'Review the operations log',
            description: 'The log at the bottom details recent operations so you can confirm what Nightshift has been doing.',
          },
        ],
      };
      const HEALTH_STATUS_COLORS = {
        healthy: 'success',
        degraded: 'warning',
        maintenance: 'info',
        offline: 'error',
        unknown: 'grey-darken-1',
      };
      const LIFECYCLE_STATE_COLORS = {
        active: 'success',
        planned: 'primary',
        maintenance: 'info',
        retired: 'grey-darken-1',
      };
      const HEALTH_STATUS_ORDER = ['healthy', 'degraded', 'maintenance', 'offline', 'unknown'];
      const LIFECYCLE_STATUS_ORDER = ['active', 'planned', 'maintenance', 'retired'];
      const HUMAN_TASK_STATUS_LABELS = {
        open: 'Open',
        in_progress: 'In progress',
        resolved: 'Resolved',
      };
      const HUMAN_TASK_STATUS_ORDER = {
        open: 0,
        in_progress: 1,
        resolved: 2,
      };
      const PROMPT_STATUS_SERVER_RESTARTING = 'server_restarting';
      const QUEUE_STATUS_BADGE_ORDER = [
        { status: 'queued', label: 'Queued', color: 'info', always: true },
        { status: 'running', label: 'Running', color: 'warning', always: true },
        { status: PROMPT_STATUS_SERVER_RESTARTING, label: 'Restarting', color: 'warning', always: false },
        { status: 'completed', label: 'Completed', color: 'success', always: false },
        { status: 'failed', label: 'Failed', color: 'error', always: false },
        { status: 'canceled', label: 'Canceled', color: 'grey-darken-1', always: false },
      ];

      const loadWorkspacePanelPreference = () => {
        if (typeof window === 'undefined' || !window.localStorage) {
          return false;
        }
        try {
          return window.localStorage.getItem(WORKSPACE_PANEL_STORAGE_KEY) === '1';
        } catch (error) {
          console.warn('Unable to read workspace layout preference', error);
          return false;
        }
      };

      const persistWorkspacePanelPreference = (collapsed) => {
        if (typeof window === 'undefined' || !window.localStorage) {
          return;
        }
        try {
          if (collapsed) {
            window.localStorage.setItem(WORKSPACE_PANEL_STORAGE_KEY, '1');
          } else {
            window.localStorage.removeItem(WORKSPACE_PANEL_STORAGE_KEY);
          }
        } catch (error) {
          console.warn('Unable to persist workspace layout preference', error);
        }
      };

      const createEmptyQueueStatusBuckets = () => {
        const buckets = {};
        QUEUE_STATUS_BADGE_ORDER.forEach(({ status }) => {
          buckets[status] = { count: 0, prompt_ids: [] };
        });
        return buckets;
      };

      const normalizeQueueStatusBuckets = (rawBuckets, items = []) => {
        const normalized = createEmptyQueueStatusBuckets();
        const ensureBucket = (status) => {
          if (!normalized[status]) {
            normalized[status] = { count: 0, prompt_ids: [] };
          }
          return normalized[status];
        };
        if (rawBuckets && typeof rawBuckets === 'object') {
          Object.entries(rawBuckets).forEach(([status, value]) => {
            const bucket = ensureBucket(status);
            const ids = Array.isArray(value?.prompt_ids)
              ? value.prompt_ids.filter((id) => typeof id === 'string' && id)
              : [];
            const count =
              typeof value?.count === 'number' && Number.isFinite(value.count) ? value.count : ids.length;
            bucket.count = count;
            bucket.prompt_ids = ids;
          });
          return normalized;
        }
        items.forEach((item) => {
          if (!item || typeof item.status !== 'string') {
            return;
          }
          const status = item.status.toLowerCase();
          const bucket = ensureBucket(status);
          bucket.count += 1;
          if (typeof item.prompt_id === 'string' && item.prompt_id) {
            bucket.prompt_ids.push(item.prompt_id);
          }
        });
        return normalized;
      };

      const HEADER_ICON_SOURCES = {
        dark: './nightshift-header-dark.png',
        light: './nightshift-header-light.png',
      };
      const FAVICON_SOURCES = {
        dark: {
          png: {
            href: './nightshift-favicon-dark.png',
            type: 'image/png',
            sizes: '256x256',
          },
          ico: {
            href: './nightshift-favicon-dark.ico',
            type: 'image/x-icon',
          },
        },
        light: {
          png: {
            href: './nightshift-favicon-light.png',
            type: 'image/png',
            sizes: '256x256',
          },
          ico: {
            href: './nightshift-favicon-light.ico',
            type: 'image/x-icon',
          },
        },
      };

      const createApiClient = (getToken, onUnauthorized) => {
        return async (path, options = {}) => {
          const headers = { 'Content-Type': 'application/json', ...(options.headers || {}) };
          const token = typeof getToken === 'function' ? getToken() : null;
          if (token) {
            headers.Authorization = `Bearer ${token}`;
          }
          const response = await fetch(path, {
            ...options,
            headers,
          });
          if (response.status === 401 && typeof onUnauthorized === 'function') {
            onUnauthorized();
          }
          if (!response.ok) {
            const err = await response.json().catch(() => ({ error: response.statusText }));
            throw new Error(err.error || 'Request failed');
          }
          return response.json();
        };
      };

      const vuetify = createVuetify({
        theme: {
          defaultTheme: 'dark',
          themes: {
            dark: {
              dark: true,
              colors: {
                background: '#0e1117',
                surface: '#161b22',
                primary: '#2563eb',
                secondary: '#7c3aed',
                success: '#10b981',
                warning: '#f97316',
                error: '#ef4444',
                info: '#38bdf8',
              },
            },
            light: {
              dark: false,
              colors: {
                background: '#f3f4f6',
                surface: '#ffffff',
                primary: '#1d4ed8',
                secondary: '#7c3aed',
                success: '#16a34a',
                warning: '#fb923c',
                error: '#dc2626',
                info: '#0ea5e9',
              },
            },
          },
        },
      });

      const appRouter = createRouter({
        history: createWebHashHistory(),
        routes: [
          {
            path: '/settings',
            name: 'settings',
            component: { template: '<div />' },
          },
          {
            path: '/:promptId?',
            name: 'queue',
            component: { template: '<div />' },
          },
        ],
      });

      createApp({
        setup() {
          const promptText = ref('');
          const queue = ref([]);
          const queueStatusBuckets = ref(createEmptyQueueStatusBuckets());
          const selectedPrompt = ref(null);
          const nowTick = ref(Date.now());
          const loading = ref(true);
          const submitting = ref(false);
          const health = ref(null);
          const operationsLog = ref('');
          const logLoading = ref(false);
          const logError = ref('');
          const logLastUpdated = ref('');
          const humanTasks = ref([]);
          const humanTasksSummary = ref({});
          const humanTasksError = ref('');
          const humanTasksLoading = ref(false);
          const clearHumanTasksLoading = ref(false);
          const clearingHumanTaskIds = ref(new Set());
          const hasActiveHumanTaskClear = computed(() => clearingHumanTaskIds.value.size > 0);
          const humanTasksRevision = ref(null);
          const humanTasksMenuOpen = ref(false);
          const humanTaskReplyTarget = ref(null);
          const expandedHumanTaskDescriptions = ref({});
          const retrying = ref(false);
          const canceling = ref(false);
          const restarting = ref(false);
          const promptStreams = reactive({});
          const editPromptDialogVisible = ref(false);
          const editPromptText = ref('');
          const editPromptError = ref('');
          const editPromptSaving = ref(false);
          const projectOptions = ref([]);
          const selectedProjectId = ref('');
          const defaultProjectId = ref(null);
          const environmentRecords = ref([]);
          const environmentLoading = ref(false);
          const environmentError = ref('');
          const environmentRevision = ref(null);
          const environmentLastFetched = ref('');
          const projectSearch = ref('');
          const workspacePanelCollapsed = ref(false);
          workspacePanelCollapsed.value = loadWorkspacePanelPreference();
          const websocketRef = ref(null);
          const wsStatus = ref('disconnected');
          const realtimeReady = ref(false);
          const reconnectAttempts = ref(0);
          const theme = useTheme();
          const themeMode = ref('dark');
          const headerIconSrc = computed(() => HEADER_ICON_SOURCES[themeMode.value] || HEADER_ICON_SOURCES.dark);
          const route = useRoute();
          const router = useRouter();
          const dateFormatter = new Intl.DateTimeFormat(undefined, { dateStyle: 'long' });
          const timeFormatter = new Intl.DateTimeFormat(undefined, { timeStyle: 'short' });
          const timestampFormatter = new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'short' });
          const queueTimestampFormatter = new Intl.DateTimeFormat(undefined, {
            month: 'short',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
          });
          const chatThreadRef = ref(null);
          const chatThreadHeight = ref(0);
          const liveStreamScrollRef = ref(null);
          let chatThreadResizeObserver = null;
          let reconnectTimer = null;
          let logRefreshTimer = null;
          let elapsedTimer = null;
          let manualRealtimeClose = false;
          const authToken = ref('');
          const currentUser = ref(null);
          const loginEmail = ref('ulfurk@ulfurk.com');
          const loginPassword = ref('');
          const showPassword = ref(false);
          const loginError = ref('');
          const loginLoading = ref(false);
          const activeView = ref('queue');
          const passwordForm = reactive({
            current: '',
            newValue: '',
            confirm: '',
          });
          const passwordChangeLoading = ref(false);
          const passwordChangeError = ref('');
          const passwordChangeSuccess = ref('');
          const sshKeys = ref([]);
          const sshKeysLoading = ref(false);
          const sshKeysError = ref('');
          const sshKeysLastFetched = ref('');
          const lastQueuePromptId = ref('');
          const viewportWidth = ref(typeof window !== 'undefined' ? window.innerWidth : MOBILE_BREAKPOINT);
          const activeMobilePanel = ref('queue');
          const isMobileLayout = computed(() => viewportWidth.value < MOBILE_BREAKPOINT);
          const mobileComposerExpanded = ref(!isMobileLayout.value);
          const isAuthenticated = computed(() => Boolean(authToken.value));
          const guidedTourActive = ref(false);
          const guidedTourStepIndex = ref(0);
          const guidedTourHighlightRect = ref(null);
          const guidedTourTargetMissing = ref(false);
          const guidedTourSteps = computed(() => GUIDED_TOUR_FLOWS[activeView.value] || []);
          const guidedTourCurrentStep = computed(() => guidedTourSteps.value[guidedTourStepIndex.value] || null);
          const guidedTourVisible = computed(() => guidedTourActive.value && Boolean(guidedTourCurrentStep.value));
          const guidedTourStepNumber = computed(() => guidedTourStepIndex.value + 1);
          const guidedTourTotalSteps = computed(() => guidedTourSteps.value.length);
          const isGuidedTourLastStep = computed(() => guidedTourStepNumber.value >= guidedTourTotalSteps.value);
          const canStartGuidedTour = computed(
            () =>
              isAuthenticated.value &&
              !isMobileLayout.value &&
              guidedTourSteps.value.length > 0
          );
          const guidedTourHighlightStyle = computed(() => {
            if (!guidedTourVisible.value || !guidedTourHighlightRect.value) {
              return { display: 'none' };
            }
            const rect = guidedTourHighlightRect.value;
            const padding = GUIDED_TOUR_PADDING;
            const top = Math.max(0, rect.top - padding);
            const left = Math.max(0, rect.left - padding);
            return {
              top: `${top}px`,
              left: `${left}px`,
              width: `${rect.width + padding * 2}px`,
              height: `${rect.height + padding * 2}px`,
            };
          });
          const resetPasswordForm = () => {
            passwordForm.current = '';
            passwordForm.newValue = '';
            passwordForm.confirm = '';
          };
          const resetSettingsState = () => {
            passwordChangeError.value = '';
            passwordChangeSuccess.value = '';
            passwordChangeLoading.value = false;
            sshKeys.value = [];
            sshKeysError.value = '';
            sshKeysLoading.value = false;
            sshKeysLastFetched.value = '';
            resetPasswordForm();
          };
          const openSettingsView = () => {
            router.push({ name: 'settings' }).catch(() => {});
          };
          const returnToQueueView = () => {
            resetSettingsState();
            if (lastQueuePromptId.value) {
              router.push({ name: 'queue', params: { promptId: lastQueuePromptId.value } }).catch(() => {});
            } else {
              router.push({ name: 'queue' }).catch(() => {});
            }
          };
          const canSubmitPassword = computed(() => {
            if (!passwordForm.current || !passwordForm.newValue || !passwordForm.confirm) {
              return false;
            }
            if (passwordForm.newValue !== passwordForm.confirm) {
              return false;
            }
            if (passwordForm.newValue === passwordForm.current) {
              return false;
            }
            return passwordForm.newValue.length >= 8;
          });

          const clearRoutePrompt = () => {
            const currentPrompt = normalizePromptId(route.params.promptId);
            if (currentPrompt || route.name !== 'queue') {
              router.replace({ name: 'queue' }).catch(() => {});
            }
          };

          const goHome = () => {
            resetSettingsState();
            router.push({ name: 'queue' }).catch(() => {});
          };

          const showQueuePanel = () => {
            if (isMobileLayout.value) {
              activeMobilePanel.value = 'queue';
            }
          };

          const showThreadPanel = () => {
            if (isMobileLayout.value && selectedPrompt.value) {
              activeMobilePanel.value = 'thread';
            }
          };

          const showWorkspacePanel = () => {
            if (isMobileLayout.value) {
              activeMobilePanel.value = 'workspaces';
              return;
            }
            workspacePanelCollapsed.value = false;
          };

          const toggleWorkspacePanel = () => {
            workspacePanelCollapsed.value = !workspacePanelCollapsed.value;
          };

          const toggleMobileComposer = () => {
            if (!isMobileLayout.value) {
              return;
            }
            mobileComposerExpanded.value = !mobileComposerExpanded.value;
          };

          watch(
            () => route.name,
            (name, previous) => {
              const nextView = name === 'settings' ? 'settings' : 'queue';
              if (activeView.value !== nextView) {
                activeView.value = nextView;
              }
              if (previous === 'settings' && nextView === 'queue') {
                resetSettingsState();
              }
            },
            { immediate: true }
          );

          watch(
            () => [route.name, route.params.promptId],
            ([name, promptId]) => {
              if (name === 'queue') {
                lastQueuePromptId.value = normalizePromptId(promptId);
              }
            },
            { immediate: true }
          );

          watch(
            selectedProjectId,
            (value) => {
              if (!value || !projectLookup.value.has(value)) {
                persistProjectSelection('');
                return;
              }
              persistProjectSelection(value);
            }
          );

          watch(workspacePanelCollapsed, (collapsed) => {
            persistWorkspacePanelPreference(Boolean(collapsed));
          });

          watch(isMobileLayout, (isMobile) => {
            if (!isMobile) {
              mobileComposerExpanded.value = true;
              activeMobilePanel.value = 'queue';
              refreshGuidedTourHighlight();
              return;
            }
            mobileComposerExpanded.value = false;
            if (guidedTourActive.value) {
              closeGuidedTour();
            }
            if (!selectedPrompt.value && activeMobilePanel.value === 'thread') {
              activeMobilePanel.value = 'queue';
            }
          });

          watch(selectedPrompt, (prompt) => {
            if (!prompt && isMobileLayout.value && activeMobilePanel.value === 'thread') {
              activeMobilePanel.value = 'queue';
            }
            refreshGuidedTourHighlight();
          });

          watch(humanTaskReplyTarget, (target) => {
            if (target && isMobileLayout.value) {
              mobileComposerExpanded.value = true;
            }
          });

          watch(promptText, (value) => {
            if (value && isMobileLayout.value) {
              mobileComposerExpanded.value = true;
            }
          });

          watch(guidedTourStepIndex, () => {
            refreshGuidedTourHighlight();
          });

          watch(
            () => guidedTourActive.value,
            (active) => {
              if (active) {
                refreshGuidedTourHighlight();
              } else {
                guidedTourHighlightRect.value = null;
                guidedTourTargetMissing.value = false;
              }
            }
          );

          watch(activeView, () => {
            if (guidedTourActive.value) {
              closeGuidedTour();
              return;
            }
            refreshGuidedTourHighlight();
          });

          watch(
            () => isAuthenticated.value,
            (authed) => {
              if (!authed && guidedTourActive.value) {
                closeGuidedTour();
              }
            }
          );

          watch(
            () => isAuthenticated.value,
            (authed) => {
              if (authed) {
                fetchEnvironments({ silent: true }).catch(() => {});
              } else {
                resetEnvironmentState();
              }
            }
          );

          const persistToken = (token) => {
            if (typeof window === 'undefined' || !window.localStorage) {
              return;
            }
            try {
              if (token) {
                window.localStorage.setItem(AUTH_TOKEN_KEY, token);
              } else {
                window.localStorage.removeItem(AUTH_TOKEN_KEY);
              }
            } catch (error) {
              console.warn('Unable to persist auth token', error);
            }
          };

          const loadStoredProjectId = () => {
            if (typeof window === 'undefined' || !window.localStorage) {
              return '';
            }
            try {
              return window.localStorage.getItem(PROJECT_STORAGE_KEY) || '';
            } catch (error) {
              console.warn('Unable to read stored project focus', error);
              return '';
            }
          };

          const persistProjectSelection = (projectId) => {
            if (typeof window === 'undefined' || !window.localStorage) {
              return;
            }
            try {
              if (projectId) {
                window.localStorage.setItem(PROJECT_STORAGE_KEY, projectId);
              } else {
                window.localStorage.removeItem(PROJECT_STORAGE_KEY);
              }
            } catch (error) {
              console.warn('Unable to persist project focus', error);
            }
          };

          const applyProjectSelection = () => {
            const availableIds = projectOptions.value
              .map((project) => project?.id)
              .filter((id) => typeof id === 'string' && id.length);
            if (!availableIds.length) {
              selectedProjectId.value = '';
              return;
            }
            const stored = loadStoredProjectId();
            const candidates = [
              stored,
              selectedProjectId.value,
              defaultProjectId.value,
              availableIds[0],
            ];
            const resolved = candidates.find((id) => id && availableIds.includes(id));
            selectedProjectId.value = resolved || '';
          };

          const resetEnvironmentState = () => {
            environmentRecords.value = [];
            environmentError.value = '';
            environmentRevision.value = null;
            environmentLoading.value = false;
            environmentLastFetched.value = '';
          };

          const resetSessionState = () => {
            queue.value = [];
            queueStatusBuckets.value = createEmptyQueueStatusBuckets();
            selectedPrompt.value = null;
            health.value = null;
            promptText.value = '';
            operationsLog.value = '';
            logLastUpdated.value = '';
            logError.value = '';
            logLoading.value = false;
            Object.keys(promptStreams).forEach((key) => delete promptStreams[key]);
            resetEnvironmentState();
          };

          const buildWebSocketUrl = () => {
            if (typeof window === 'undefined') {
              return '';
            }
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            return `${protocol}//${window.location.host}/ws`;
          };

          const clearReconnectTimer = () => {
            if (reconnectTimer) {
              clearTimeout(reconnectTimer);
              reconnectTimer = null;
            }
          };

          const clearLogRefreshTimer = () => {
            if (logRefreshTimer) {
              clearInterval(logRefreshTimer);
              logRefreshTimer = null;
            }
          };

          const stopLogRefresh = () => {
            clearLogRefreshTimer();
          };

          const disconnectRealtime = ({ manual = false } = {}) => {
            if (manual) {
              manualRealtimeClose = true;
            }
            clearReconnectTimer();
            realtimeReady.value = false;
            wsStatus.value = 'disconnected';
            const socket = websocketRef.value;
            if (socket) {
              websocketRef.value = null;
              try {
                socket.close();
              } catch (error) {
                console.warn('Unable to close realtime socket', error);
              }
            }
          };

          const scheduleReconnect = () => {
            if (!isAuthenticated.value || manualRealtimeClose) {
              return;
            }
            clearReconnectTimer();
            const attempt = reconnectAttempts.value + 1;
            reconnectAttempts.value = attempt;
            const delay = Math.min(WS_RECONNECT_MIN_MS * 2 ** (attempt - 1), WS_RECONNECT_MAX_MS);
            reconnectTimer = setTimeout(() => {
              connectRealtime();
            }, delay);
          };

          const sendRealtimeMessage = (message) => {
            if (!websocketRef.value || websocketRef.value.readyState !== WebSocket.OPEN) {
              return false;
            }
            try {
              websocketRef.value.send(JSON.stringify(message));
              return true;
            } catch (error) {
              console.error('Unable to send realtime payload', error);
              return false;
            }
          };

          const handleRealtimeMessage = (event) => {
            let packet;
            try {
              packet = JSON.parse(event.data);
            } catch (error) {
              console.warn('Unable to parse realtime payload', error);
              return;
            }
            const { type, payload } = packet || {};
            switch (type) {
              case 'auth_ok':
                realtimeReady.value = true;
                if (payload?.user) {
                  currentUser.value = payload.user;
                }
                loading.value = false;
                sendRealtimeMessage({ type: 'request_queue' });
                if (selectedPrompt.value?.prompt_id) {
                  sendRealtimeMessage({ type: 'fetch_prompt', prompt_id: selectedPrompt.value.prompt_id });
                }
                break;
              case 'queue_snapshot':
                applyQueueSnapshot(payload);
                loading.value = false;
                break;
              case 'prompt_update':
                if (payload?.prompt) {
                  mergeQueueEntry(payload.prompt);
                  if (selectedPrompt.value?.prompt_id === payload.prompt.prompt_id) {
                    selectedPrompt.value = payload.prompt;
                  }
                  const status = (payload.prompt.status || '').toLowerCase();
                  if (status === 'completed' || status === 'failed') {
                    clearStreamState(payload.prompt.prompt_id);
                  }
                }
                break;
              case 'prompt_deleted': {
                const deletedId = payload?.prompt_id;
                if (deletedId) {
                  const index = queue.value.findIndex((item) => item.prompt_id === deletedId);
                  if (index !== -1) {
                    queue.value.splice(index, 1);
                    refreshLocalQueueStatusBuckets();
                  }
                  if (selectedPrompt.value?.prompt_id === deletedId) {
                    selectedPrompt.value = null;
                    router.replace({ name: 'queue' }).catch(() => {});
                  }
                  clearStreamState(deletedId);
                }
                break;
              }
              case 'health':
                health.value = payload;
                applyHumanTaskMetrics(payload?.metrics?.human_tasks);
                applyEnvironmentMetrics(payload?.metrics?.environments);
                break;
              case 'prompt_stream':
                handleStreamPayload(payload);
                break;
              case 'hello':
              case 'pong':
                break;
              case 'error':
                console.error('Realtime error', payload?.message || payload);
                break;
              default:
                console.debug('Unhandled realtime packet', packet);
            }
          };

          const handleStreamPayload = (payload) => {
            const promptId = payload?.prompt_id;
            if (!promptId) {
              return;
            }
            const streamName = (payload?.stream || '').toLowerCase();
            if (streamName !== 'stdout' && streamName !== 'stderr') {
              return;
            }
            const state = getStreamState(promptId);
            if (!state) {
              return;
            }
            const timestamp = payload.timestamp || new Date().toISOString();
            if (payload.reset) {
              state.stdout = '';
              state.stderr = '';
              state.done = false;
              state.started_at = timestamp;
            }
            if (!state.started_at) {
              state.started_at = timestamp;
            }
            if (typeof payload.chunk === 'string' && payload.chunk.length) {
              state[streamName] = (state[streamName] || '') + payload.chunk;
            }
            if (payload.done) {
              state.done = true;
            }
            state.updated_at = timestamp;
            if (selectedPrompt.value?.prompt_id === promptId) {
              selectedPrompt.value = {
                ...selectedPrompt.value,
                live_stream: { ...state },
              };
            }
          };

          const connectRealtime = () => {
            if (!isAuthenticated.value || wsStatus.value === 'connecting' || wsStatus.value === 'open') {
              return;
            }
            manualRealtimeClose = false;
            clearReconnectTimer();
            const url = buildWebSocketUrl();
            if (!url) {
              return;
            }
            wsStatus.value = 'connecting';
            try {
              const socket = new WebSocket(url);
              websocketRef.value = socket;

              socket.addEventListener('open', () => {
                wsStatus.value = 'open';
                reconnectAttempts.value = 0;
                sendRealtimeMessage({ type: 'auth', token: authToken.value });
              });
              socket.addEventListener('message', handleRealtimeMessage);
              socket.addEventListener('close', () => {
                websocketRef.value = null;
                realtimeReady.value = false;
                wsStatus.value = 'closed';
                if (!manualRealtimeClose) {
                  scheduleReconnect();
                }
              });
              socket.addEventListener('error', (error) => {
                console.error('Realtime socket error', error);
                socket.close();
              });
            } catch (error) {
              console.error('Unable to open realtime socket', error);
              scheduleReconnect();
            }
          };

          const handleUnauthorized = (message) => {
            disconnectRealtime({ manual: true });
            stopLogRefresh();
            resetSessionState();
            resetSettingsState();
            activeView.value = 'queue';
            authToken.value = '';
            currentUser.value = null;
            loading.value = false;
            submitting.value = false;
            retrying.value = false;
            canceling.value = false;
            restarting.value = false;
            persistToken('');
            clearRoutePrompt();
            humanTasks.value = [];
            humanTasksSummary.value = {};
            humanTasksRevision.value = null;
            humanTasksError.value = '';
            humanTasksLoading.value = false;
            clearHumanTasksLoading.value = false;
            humanTasksMenuOpen.value = false;
            humanTaskReplyTarget.value = null;
            expandedHumanTaskDescriptions.value = {};
            if (message) {
              loginError.value = message;
            }
          };

          const api = createApiClient(
            () => authToken.value,
            () => handleUnauthorized('Session expired. Please sign in again.')
          );

          const formatDate = (isoString) => {
            if (!isoString) return '—';
            try {
              const date = new Date(isoString);
              return `${dateFormatter.format(date)} at ${timeFormatter.format(date)}`;
            } catch (error) {
              console.error('Unable to format date', error);
              return isoString;
            }
          };

          const formatTimestamp = (isoString) => {
            if (!isoString) return '—';
            try {
              return timestampFormatter.format(new Date(isoString));
            } catch (error) {
              console.error('Unable to format timestamp', error);
              return isoString;
            }
          };

          const formatDuration = (seconds) => {
            if (seconds == null || Number.isNaN(seconds)) {
              return '—';
            }
            if (seconds < 1) {
              return `${Math.round(seconds * 1000)} ms`;
            }
            if (seconds < 10) {
              return `${seconds.toFixed(1)} s`;
            }
            return `${Math.round(seconds)} s`;
          };

          const formatQueueDuration = (seconds) => {
            if (seconds == null || Number.isNaN(seconds)) {
              return '—';
            }
            const totalSeconds = Math.max(0, Math.round(seconds));
            const minutes = Math.floor(totalSeconds / 60);
            const remainingSeconds = totalSeconds % 60;
            return `${minutes}m ${remainingSeconds.toString().padStart(2, '0')}s`;
          };

          const formatHumanTaskStatus = (status) => {
            if (!status) {
              return 'Unknown';
            }
            const normalized = String(status).toLowerCase();
            return HUMAN_TASK_STATUS_LABELS[normalized] || status;
          };

          const normalizeWhitespace = (value) => {
            if (!value) return '';
            return value.replace(/\s+/g, ' ').trim();
          };

          const CODE_FENCE_REGEX = /```([\s\S]*?)```/g;
          const CODE_PREVIEW_MAX_CHARS = 96;

          const buildCodeBlockPreview = (content) => {
            if (!content) {
              return 'Code block';
            }
            const normalized = content.replace(/\s+/g, ' ').trim();
            if (!normalized) {
              return 'Code block';
            }
            if (normalized.length > CODE_PREVIEW_MAX_CHARS) {
              return `${normalized.slice(0, CODE_PREVIEW_MAX_CHARS - 1)}…`;
            }
            return normalized;
          };

          const collapseThinkingSections = (content) => {
            if (!content || !content.includes('thinking')) {
              return content;
            }
            const lines = content.split('\n');
            if (lines.length < 3) {
              return content;
            }
            const collapsedLines = [];
            for (let i = 0; i < lines.length; i++) {
              const trimmed = lines[i].trim();
              if (trimmed !== 'thinking') {
                collapsedLines.push(lines[i]);
                continue;
              }
              const titleLine = lines[i + 1];
              if (!titleLine) {
                collapsedLines.push(lines[i]);
                continue;
              }
              const titleMatch = titleLine.trim().match(/^\*\*(.+?)\*\*$/);
              if (!titleMatch) {
                collapsedLines.push(lines[i]);
                continue;
              }
              const titleText = titleMatch[1].trim() || titleMatch[1];
              let nextIndex = i + 2;
              while (nextIndex < lines.length && !lines[nextIndex].trim()) {
                nextIndex += 1;
              }
              if (nextIndex < lines.length) {
                const candidate = lines[nextIndex].trim();
                if (candidate && candidate.toLowerCase() !== 'thinking' && !candidate.startsWith('**')) {
                  nextIndex += 1;
                }
              }
              collapsedLines.push(titleText);
              i = nextIndex - 1;
            }
            return collapsedLines.join('\n');
          };

          const parseCodeAndTextSegments = (chunk) => {
            const rawContent = chunk == null ? '' : String(chunk);
            if (!rawContent) {
              return [];
            }
            const content = collapseThinkingSections(rawContent);
            const segments = [];
            let lastIndex = 0;
            CODE_FENCE_REGEX.lastIndex = 0;
            let match;
            while ((match = CODE_FENCE_REGEX.exec(content)) !== null) {
              if (match.index > lastIndex) {
                segments.push({
                  type: 'text',
                  content: content.slice(lastIndex, match.index),
                });
              }
              const rawBlock = match[1] || '';
              let language = '';
              let codeContent = rawBlock;
              const newlineIndex = rawBlock.indexOf('\n');
              if (newlineIndex !== -1) {
                const firstLine = rawBlock.slice(0, newlineIndex).trim();
                const remainder = rawBlock.slice(newlineIndex + 1);
                if (firstLine && remainder) {
                  language = firstLine;
                  codeContent = remainder;
                } else if (!firstLine) {
                  codeContent = remainder;
                }
              }
              segments.push({
                type: 'code',
                language,
                content: codeContent,
                preview: buildCodeBlockPreview(codeContent || rawBlock),
              });
              lastIndex = match.index + match[0].length;
            }
            if (lastIndex < content.length) {
              segments.push({
                type: 'text',
                content: content.slice(lastIndex),
              });
            }
            return segments;
          };

          const findCollapseRanges = (text) => {
            if (!text) {
              return [];
            }
            const normalizedText = text.toLowerCase();
            if (!normalizedText.includes('exec') && !normalizedText.includes('file update')) {
              return [];
            }
            const lines = text.split('\n');
            const linePositions = [];
            let cursor = 0;
            for (let i = 0; i < lines.length; i++) {
              const lineText = lines[i];
              const start = cursor;
              const end = start + lineText.length;
              const newlineLength = i < lines.length - 1 ? 1 : 0;
              linePositions.push({
                value: lineText,
                start,
                end,
                newlineLength,
              });
              cursor = end + newlineLength;
            }
            const ranges = [];
            for (let i = 0; i < linePositions.length; i++) {
              const entry = linePositions[i];
              const trimmedValue = entry.value.trim();
              const normalizedLine = trimmedValue.toLowerCase();
              let markerType = null;
              if (normalizedLine === 'exec') {
                markerType = 'exec';
              } else if (normalizedLine === 'file update' || normalizedLine.startsWith('file update:')) {
                markerType = 'file-update';
              } else {
                continue;
              }
              const rangeStart = entry.end + entry.newlineLength;
              if (rangeStart >= text.length) {
                continue;
              }
              let rangeEnd = text.length;
              for (let j = i + 1; j < linePositions.length; j++) {
                if (linePositions[j].value.trim() === 'thinking') {
                  rangeEnd = linePositions[j].start;
                  break;
                }
              }
              if (rangeEnd <= rangeStart) {
                continue;
              }
              ranges.push({ start: rangeStart, end: rangeEnd, type: markerType });
            }
            return ranges;
          };

          const parseOutputSegments = (value) => {
            const text = value == null ? '' : String(value);
            if (!text) {
              return [];
            }
            const collapseRanges = findCollapseRanges(text);
            if (!collapseRanges.length) {
              return parseCodeAndTextSegments(text);
            }
            const segments = [];
            let cursor = 0;
            const sortedRanges = collapseRanges.slice().sort((a, b) => a.start - b.start);
            sortedRanges.forEach((range) => {
              if (cursor < range.start) {
                const chunk = text.slice(cursor, range.start);
                segments.push(...parseCodeAndTextSegments(chunk));
              }
              const collapsedStart = Math.max(cursor, range.start);
              const collapsedEnd = Math.max(collapsedStart, range.end);
              if (collapsedEnd > collapsedStart) {
                const collapsedContent = text.slice(collapsedStart, collapsedEnd);
                if (collapsedContent) {
                  const previewText = buildCodeBlockPreview(collapsedContent);
                  segments.push({
                    type: range.type,
                    content: collapsedContent,
                    preview:
                      previewText === 'Code block'
                        ? range.type === 'file-update'
                          ? 'File diff'
                          : 'Command output'
                        : previewText,
                  });
                }
              }
              cursor = Math.max(cursor, range.end);
            });
            if (cursor < text.length) {
              segments.push(...parseCodeAndTextSegments(text.slice(cursor)));
            }
            return segments;
          };

          const formatQueueTimestamp = (isoString) => {
            if (!isoString) return '--';
            try {
              return queueTimestampFormatter.format(new Date(isoString));
            } catch (error) {
              console.error('Unable to format queue timestamp', error);
              return isoString;
            }
          };

          const normalizePromptId = (value) => {
            if (value == null) {
              return '';
            }
            return String(value);
          };

          const computeRuntimeSeconds = (startIso, endIso) => {
            if (!startIso || !endIso) {
              return null;
            }
            const start = new Date(startIso);
            const end = new Date(endIso);
            const elapsedMs = end - start;
            if (!Number.isFinite(elapsedMs) || elapsedMs < 0) {
              return null;
            }
            return elapsedMs / 1000;
          };

          const getStreamState = (promptId) => {
            if (!promptId) return null;
            if (!promptStreams[promptId]) {
              promptStreams[promptId] = {
                stdout: '',
                stderr: '',
                updated_at: null,
                started_at: null,
                done: false,
              };
            }
            return promptStreams[promptId];
          };

          const clearStreamState = (promptId) => {
            if (!promptId || !promptStreams[promptId]) return;
            delete promptStreams[promptId];
            if (selectedPrompt.value?.prompt_id === promptId) {
              selectedPrompt.value = { ...selectedPrompt.value, live_stream: null };
            }
          };

          const syncQueueItems = (items = []) => {
            const normalized = items.map((item) => ({ ...item }));
            if (!queue.value.length) {
              queue.value = normalized;
              return;
            }
            const existingLookup = new Map(queue.value.map((entry) => [entry.prompt_id, entry]));
            const merged = normalized.map((item) => {
              const current = existingLookup.get(item.prompt_id);
              if (current) {
                Object.assign(current, item);
                return current;
              }
              return item;
            });
            queue.value.splice(0, queue.value.length, ...merged);
          };

          const refreshLocalQueueStatusBuckets = () => {
            queueStatusBuckets.value = normalizeQueueStatusBuckets(null, queue.value);
          };

          const applyQueueSnapshot = (snapshot) => {
            if (!snapshot) {
              syncQueueItems([]);
              queueStatusBuckets.value = normalizeQueueStatusBuckets(null, []);
              return;
            }
            if (Array.isArray(snapshot)) {
              syncQueueItems(snapshot);
              queueStatusBuckets.value = normalizeQueueStatusBuckets(null, snapshot);
              return;
            }
            const items = Array.isArray(snapshot.items) ? snapshot.items : [];
            syncQueueItems(items);
            queueStatusBuckets.value = normalizeQueueStatusBuckets(snapshot.status_buckets, items);
          };

          const mergeQueueEntry = (entry) => {
            if (!entry || !entry.prompt_id) {
              return;
            }
            const index = queue.value.findIndex((item) => item.prompt_id === entry.prompt_id);
            if (index === -1) {
              queue.value.unshift({ ...entry });
            } else {
              Object.assign(queue.value[index], entry);
            }
            refreshLocalQueueStatusBuckets();
          };

          const formatStatus = (status) => {
            if (!status) return 'Unknown';
            const normalized = status.toString().toLowerCase();
            return normalized.charAt(0).toUpperCase() + normalized.slice(1);
          };

          const getHealthStatusColor = (status) => {
            if (!status) {
              return HEALTH_STATUS_COLORS.unknown;
            }
            return HEALTH_STATUS_COLORS[status.toLowerCase()] || HEALTH_STATUS_COLORS.unknown;
          };

          const getLifecycleStatusColor = (state) => {
            if (!state) {
              return LIFECYCLE_STATE_COLORS.planned;
            }
            return LIFECYCLE_STATE_COLORS[state.toLowerCase()] || LIFECYCLE_STATE_COLORS.planned;
          };

          const isFailedStatus = (status) => (status || '').toLowerCase() === 'failed';
          const isRunningStatus = (status) => (status || '').toLowerCase() === 'running';
          const EDITABLE_PROMPT_STATUSES = new Set(['queued', 'failed', 'completed', 'canceled']);

          const attemptLogs = computed(() => {
            if (!selectedPrompt.value?.attempt_logs?.length) {
              return [];
            }
            return [...selectedPrompt.value.attempt_logs].sort((a, b) => {
              return new Date(a.received_at || 0) - new Date(b.received_at || 0);
            });
          });

          const globalContext = computed(() => selectedPrompt.value?.agents_context || '');

          const projectLookup = computed(() => {
            const map = new Map();
            projectOptions.value.forEach((project) => {
              if (project && project.id) {
                map.set(project.id, project);
              }
            });
            return map;
          });

          const activeProjectId = computed(() => {
            const current = selectedProjectId.value;
            if (current && projectLookup.value.has(current)) {
              return current;
            }
            const fallback = defaultProjectId.value;
            if (fallback && projectLookup.value.has(fallback)) {
              return fallback;
            }
            const first = projectOptions.value.find((project) => project?.id);
            return first ? first.id : null;
          });

          const activeProject = computed(() => {
            const id = activeProjectId.value;
            if (!id) {
              return null;
            }
            return projectLookup.value.get(id) || null;
          });

          const activeProjectLaunchUrl = computed(() => activeProject.value?.launch_url || '');

          const selectedPromptProject = computed(() => {
            const prompt = selectedPrompt.value;
            if (!prompt) {
              return null;
            }
            if (prompt.project?.id) {
              return prompt.project;
            }
            if (prompt.project_id && projectLookup.value.has(prompt.project_id)) {
              return projectLookup.value.get(prompt.project_id);
            }
            return null;
          });

          const selectedPromptProjectName = computed(() => selectedPromptProject.value?.name || '');

          const activeStream = computed(() => {
            const id = selectedPrompt.value?.prompt_id;
            if (!id) return null;
            return promptStreams[id] || null;
          });

          const showLiveStream = computed(() => {
            const stream = activeStream.value;
            if (!stream) {
              return false;
            }
            if (stream.stdout || stream.stderr) {
              return true;
            }
            return !stream.done;
          });

          const liveAttemptNumber = computed(() => {
            if (!showLiveStream.value) {
              return null;
            }
            const reportedAttempts = Number(selectedPrompt.value?.attempts);
            if (Number.isFinite(reportedAttempts) && reportedAttempts > attemptLogs.value.length) {
              return reportedAttempts;
            }
            return attemptLogs.value.length + 1;
          });

          const liveAttemptReceivedAt = computed(() => {
            const stream = activeStream.value;
            if (stream?.started_at) {
              return stream.started_at;
            }
            if (selectedPrompt.value?.live_stream?.started_at) {
              return selectedPrompt.value.live_stream.started_at;
            }
            if (selectedPrompt.value?.started_at) {
              return selectedPrompt.value.started_at;
            }
            return selectedPrompt.value?.updated_at || selectedPrompt.value?.created_at || null;
          });

          const liveAttemptDurationSeconds = computed(() => {
            const stream = activeStream.value;
            const start = liveAttemptReceivedAt.value;
            if (!start) {
              return null;
            }
            const status = (selectedPrompt.value?.status || '').toLowerCase();
            if (status === 'running') {
              return computeRuntimeSeconds(start, nowTick.value);
            }
            if (stream?.updated_at) {
              return computeRuntimeSeconds(start, stream.updated_at);
            }
            if (selectedPrompt.value?.updated_at) {
              return computeRuntimeSeconds(start, selectedPrompt.value.updated_at);
            }
            return null;
          });

          const queueEntries = computed(() => {
            const lookup = projectLookup.value;
            const focusProjectId = activeProjectId.value;
            const nowMs = nowTick.value;
            return queue.value
              .map((item, index) => {
                const status = (item.status || '').toLowerCase();
                const isCompleted = status === 'completed';
                const isFailed = status === 'failed';
                const isCanceled = status === 'canceled';
                const isRunning = isRunningStatus(status);
                let runtimeSeconds = null;
                if (isCompleted || isFailed || isCanceled) {
                  runtimeSeconds = computeRuntimeSeconds(item.created_at, item.updated_at);
                } else if (isRunning) {
                  const runningStart = item.started_at || item.updated_at || item.created_at;
                  runtimeSeconds = computeRuntimeSeconds(runningStart, nowMs);
                }
                let detailSource = item.text || '';
                if (isCompleted) {
                  detailSource = item.stdout_preview || item.result_summary || '';
                } else if (isCanceled) {
                  detailSource = item.result_summary || 'Prompt canceled by user';
                }
                const normalizedDetail = normalizeWhitespace(detailSource);
                const placeholder = isCompleted
                  ? 'Stdout unavailable'
                  : isCanceled
                    ? 'Prompt canceled'
                    : 'Prompt unavailable';
                const detailLimit = isMobileLayout.value ? QUEUE_DETAIL_MOBILE_MAX : QUEUE_DETAIL_MAX;
                const detail =
                  normalizedDetail.length > detailLimit
                    ? `${normalizedDetail.slice(0, detailLimit - 1)}…`
                    : normalizedDetail || placeholder;
                const entryProjectId = item.project?.id || item.project_id || null;
                if (focusProjectId && entryProjectId !== focusProjectId) {
                  return null;
                }
                const queuePosition =
                  typeof item.queue_position === 'number'
                    ? item.queue_position
                    : typeof item.queuePosition === 'number'
                      ? item.queuePosition
                      : index + 1;
                return {
                  ...item,
                  queueIndex: queuePosition,
                  createdDisplay: formatQueueTimestamp(item.created_at),
                  runtimeDisplay: runtimeSeconds != null ? formatQueueDuration(runtimeSeconds) : null,
                  detailLine: detail,
                };
              })
              .filter(Boolean);
          });

          watch(
            () => queueEntries.value.length,
            () => {
              refreshGuidedTourHighlight();
            }
          );

          const humanTaskEntries = computed(() => {
            const entries = humanTasks.value.map((task) => {
              const normalizedStatus = (task?.status || '').toLowerCase();
              const projectName =
                task?.project?.name ||
                task?.project?.id ||
                task?.project_id ||
                (task?.project && typeof task.project === 'string' ? task.project : '') ||
                'Unscoped';
              const description = normalizeWhitespace(task?.description || '');
              const hasDescription = Boolean(description);
              const descriptionDisplay = hasDescription ? description : 'No description provided.';
              const isTruncated = description.length > HUMAN_TASK_DESCRIPTION_PREVIEW_LIMIT;
              const snippet = isTruncated
                ? `${description.slice(0, HUMAN_TASK_DESCRIPTION_PREVIEW_LIMIT - 1)}…`
                : descriptionDisplay;
              return {
                ...task,
                statusDisplay: formatHumanTaskStatus(normalizedStatus || task?.status),
                projectDisplay: projectName,
                descriptionSnippet: snippet,
                descriptionFull: descriptionDisplay,
                descriptionIsTruncated: isTruncated,
              };
            });
            return entries.sort((a, b) => {
              if (a.blocking !== b.blocking) {
                return a.blocking ? -1 : 1;
              }
              const statusRankA = HUMAN_TASK_STATUS_ORDER[a.status] ?? 99;
              const statusRankB = HUMAN_TASK_STATUS_ORDER[b.status] ?? 99;
              if (statusRankA !== statusRankB) {
                return statusRankA - statusRankB;
              }
              if (a.created_at && b.created_at) {
                return a.created_at.localeCompare(b.created_at);
              }
              return 0;
            });
          });

          const isHumanTaskDescriptionExpanded = (taskId) => {
            if (!taskId) {
              return false;
            }
            return Boolean(expandedHumanTaskDescriptions.value[taskId]);
          };

          const toggleHumanTaskDescription = (taskId) => {
            if (!taskId) {
              return;
            }
            const current = Boolean(expandedHumanTaskDescriptions.value[taskId]);
            expandedHumanTaskDescriptions.value = {
              ...expandedHumanTaskDescriptions.value,
              [taskId]: !current,
            };
          };

          watch(humanTasks, (tasks) => {
            const current = expandedHumanTaskDescriptions.value;
            const next = {};
            tasks.forEach((task) => {
              const id = task?.task_id;
              if (id && current[id]) {
                next[id] = true;
              }
            });
            expandedHumanTaskDescriptions.value = next;
          });

          const formatHumanTaskReference = (task) => {
            if (!task) {
              return '';
            }
            const normalizedTitle = normalizeWhitespace(task.title || '');
            if (normalizedTitle) {
              return normalizedTitle;
            }
            if (task.task_id) {
              return `Task ${task.task_id}`;
            }
            return 'Human task';
          };

          const blockingHumanTaskCount = computed(() => {
            const summary = humanTasksSummary.value || {};
            return summary.blocking_count || 0;
          });

          const openHumanTaskCount = computed(() => {
            const counts = (humanTasksSummary.value && humanTasksSummary.value.status_counts) || {};
            return counts.open || 0;
          });

          const formatHumanTaskBadgeCount = (value) => {
            const numeric = typeof value === 'number' ? value : Number(value) || 0;
            if (numeric > 99) {
              return '99+';
            }
            return String(numeric);
          };

          const formatQueueBadgeCount = (value) => formatHumanTaskBadgeCount(value);

          const humanTasksBadgeState = computed(() => {
            const errorMessage = humanTasksError.value;
            if (errorMessage) {
              return {
                icon: 'mdi-bell-alert-outline',
                badgeColor: 'error',
                badgeText: '!',
                showBadge: true,
                label: `Human tasks unavailable: ${errorMessage}`,
              };
            }
            const blocking = blockingHumanTaskCount.value;
            if (blocking > 0) {
              return {
                icon: 'mdi-bell-alert',
                badgeColor: 'error',
                badgeText: formatHumanTaskBadgeCount(blocking),
                showBadge: true,
                label: blocking === 1 ? '1 blocking human task' : `${blocking} blocking human tasks`,
              };
            }
            const open = openHumanTaskCount.value;
            if (open > 0) {
              return {
                icon: 'mdi-bell-badge',
                badgeColor: 'warning',
                badgeText: formatHumanTaskBadgeCount(open),
                showBadge: true,
                label: open === 1 ? '1 open human task' : `${open} open human tasks`,
              };
            }
            return {
              icon: 'mdi-bell-outline',
              badgeColor: '',
              badgeText: '',
              showBadge: false,
              label: 'No human tasks waiting',
            };
          });

          const humanTasksMenuLabel = computed(() => {
            if (humanTasksLoading.value && !humanTaskEntries.value.length) {
              return 'Loading human tasks';
            }
            return humanTasksBadgeState.value.label;
          });

          const projectTaskLookup = computed(() => {
            const buckets = new Map();
            humanTasks.value.forEach((task) => {
              const projectId = task?.project?.id || task?.project_id || null;
              if (!projectId) {
                return;
              }
              const bucket = buckets.get(projectId) || { tasks: [], blocking: 0, open: 0 };
              bucket.tasks.push(task);
              if (task.blocking) {
                bucket.blocking += 1;
              }
              const normalizedStatus = (task.status || '').toLowerCase();
              if (normalizedStatus === 'open' || normalizedStatus === 'in_progress') {
                bucket.open += 1;
              }
              buckets.set(projectId, bucket);
            });
            return buckets;
          });

          const mapEnvironmentToWorkspace = (env, projectLookupMap, taskBuckets) => {
            const projectId = env?.project?.id || env?.project_id || '';
            const project = env?.project || (projectId ? projectLookupMap.get(projectId) : null);
            const lifecycleState = (env?.lifecycle?.state || 'planned').toLowerCase();
            const healthStatus = (env?.health?.status || 'unknown').toLowerCase();
            const host = env?.host || {};
            const owner = env?.owner || {};
            const ports = Array.isArray(env?.ports) ? env.ports : [];
            const quickLinks = ports
              .filter((port) => port?.url)
              .map((port) => ({
                label: port?.name || port?.url,
                url: port?.url,
                description: port?.description || '',
              }));
            const primaryLink = quickLinks.length ? quickLinks[0].url : env?.health?.url || '';
            const bucket = projectId ? taskBuckets.get(projectId) : null;
            const baseId = env.environment_id || env.id || env.slug || env.name || primaryLink;
            const fallbackId = [projectId || 'unscoped', baseId || 'environment'].join('-');
            return {
              id: baseId || fallbackId,
              name: env.name || env.slug || 'Unnamed runtime',
              projectId,
              projectName: project?.name || projectId || 'Unscoped',
              lifecycleState,
              healthStatus,
              hostDisplay: host?.hostname
                ? [host.hostname, host.region || host.provider].filter(Boolean).join(' · ')
                : '',
              ownerDisplay: owner?.name
                ? [owner.name, owner.role || owner.email].filter(Boolean).join(' · ')
                : '',
              quickLinks,
              primaryLink,
              blockingTasks: bucket?.blocking || 0,
              openTasks: bucket?.open || 0,
              updated_at: env.updated_at || '',
            };
          };

          const projectEnvironmentLookup = computed(() => {
            const lookup = new Map();
            const projectLookupMap = projectLookup.value;
            const taskBuckets = projectTaskLookup.value;
            environmentRecords.value.forEach((env) => {
              const projectId = env?.project?.id || env?.project_id || '';
              const key = projectId || '__unscoped__';
              const normalized = mapEnvironmentToWorkspace(env, projectLookupMap, taskBuckets);
              const list = lookup.get(key) || [];
              list.push(normalized);
              lookup.set(key, list);
            });
            lookup.forEach((list) => list.sort((a, b) => a.name.localeCompare(b.name)));
            return lookup;
          });

          const projectDirectoryEntries = computed(() => {
            const search = projectSearch.value.trim().toLowerCase();
            const environmentLookup = projectEnvironmentLookup.value;
            const taskBuckets = projectTaskLookup.value;
            const entries = projectOptions.value.map((project) => {
              const spec = project?.spec || {};
              const runtimes = Array.isArray(spec?.runtimes) ? spec.runtimes : [];
              const runtimeSummary = runtimes.map((runtime) => runtime?.name).filter(Boolean).join(', ');
              const sources = Array.isArray(spec?.sources) ? spec.sources : [];
              const sourceSummary = sources
                .map((source) => source?.name || source?.url)
                .filter(Boolean)
                .slice(0, 2)
                .join(', ');
              const contacts = Array.isArray(spec?.contacts) ? spec.contacts : [];
              const primaryContact = contacts.length
                ? [contacts[0]?.name, contacts[0]?.role].filter(Boolean).join(' · ')
                : '';
              const bucket = taskBuckets.get(project.id) || { blocking: 0, open: 0, tasks: [] };
              const environments = environmentLookup.get(project.id) || [];
              return {
                ...project,
                runtimeSummary,
                sourceSummary,
                primaryContact,
                environments,
                environmentCount: environments.length,
                blockingTasks: bucket.blocking || 0,
                openTasks: bucket.open || 0,
                hasHumanTasks: (bucket.blocking || 0) + (bucket.open || 0) > 0,
              };
            });
            const unscopedEnvironments = environmentLookup.get('__unscoped__') || [];
            if (unscopedEnvironments.length) {
              entries.push({
                id: '__unscoped__',
                name: 'Unscoped workspaces',
                description: 'Runtimes missing a linked workspace spec.',
                runtimeSummary: '',
                sourceSummary: '',
                primaryContact: '',
                environments: unscopedEnvironments,
                environmentCount: unscopedEnvironments.length,
                blockingTasks: 0,
                openTasks: 0,
                hasHumanTasks: unscopedEnvironments.some(
                  (env) => (env.blockingTasks || 0) + (env.openTasks || 0) > 0
                ),
              });
            }
            return entries
              .filter((entry) => {
                if (!search) {
                  return true;
                }
                const haystack = [entry.name, entry.description, entry.id, entry.primaryContact]
                  .filter(Boolean)
                  .join(' ')
                  .toLowerCase();
                return haystack.includes(search);
              })
              .sort((a, b) => (a.name || '').localeCompare(b.name || ''));
          });

          const projectDirectorySummary = computed(() => {
            if (!projectOptions.value.length) {
              return 'No workspaces registered yet.';
            }
            if (!projectSearch.value.trim()) {
              const total = projectOptions.value.length;
              return `${total} workspace${total === 1 ? '' : 's'} tracked`;
            }
            const matches = projectDirectoryEntries.value.length;
            return `${matches} match${matches === 1 ? '' : 'es'} · ${projectOptions.value.length} total`;
          });

          const normalizeCodexLimitLine = (limit, fallbackLabel) => {
            if (!limit || typeof limit !== 'object') {
              return null;
            }
            const label = String(limit.label || '').trim() || fallbackLabel;
            const value = String(limit.value || '').trim();
            return { label, value };
          };

          const codexStatusInfo = computed(() => {
            const status = health.value?.codex_status;
            if (!status || typeof status !== 'object') {
              return null;
            }
            const result = {
              error: typeof status.error === 'string' ? status.error : '',
              fiveHour: normalizeCodexLimitLine(status.five_hour, '5h limit'),
              weekly: normalizeCodexLimitLine(status.weekly, 'Weekly limit'),
            };
            if (!result.error && !result.fiveHour && !result.weekly) {
              return null;
            }
            return result;
          });

          const canEditSelectedPrompt = computed(() => {
            if (!selectedPrompt.value) {
              return false;
            }
            const status = (selectedPrompt.value.status || '').toLowerCase();
            return EDITABLE_PROMPT_STATUSES.has(status);
          });

          const canCancelSelectedPrompt = computed(() => {
            if (!selectedPrompt.value) {
              return false;
            }
            const status = (selectedPrompt.value.status || '').toLowerCase();
            if (status === 'queued') {
              return true;
            }
            return isRunningStatus(status);
          });
          const canRestartSelectedPrompt = computed(() => {
            if (!selectedPrompt.value) {
              return false;
            }
            return (selectedPrompt.value.status || '').toLowerCase() === 'canceled';
          });

          const attemptKey = (attempt, index) => `${attempt.received_at || 'attempt'}-${index}`;

          const resolveGuidedTourTarget = (step) => {
            if (!step || typeof document === 'undefined') {
              return null;
            }
            if (typeof step.target === 'function') {
              try {
                return step.target();
              } catch (error) {
                console.warn('Unable to resolve guided tour target', error);
                return null;
              }
            }
            if (typeof step.target === 'string' && step.target) {
              return document.querySelector(step.target);
            }
            return null;
          };

          const updateGuidedTourHighlightRect = () => {
            if (!guidedTourActive.value) {
              guidedTourHighlightRect.value = null;
              guidedTourTargetMissing.value = false;
              return;
            }
            const step = guidedTourCurrentStep.value;
            if (!step) {
              guidedTourHighlightRect.value = null;
              guidedTourTargetMissing.value = false;
              return;
            }
            const target = resolveGuidedTourTarget(step);
            if (!target) {
              guidedTourHighlightRect.value = null;
              guidedTourTargetMissing.value = true;
              return;
            }
            const rect = target.getBoundingClientRect();
            guidedTourHighlightRect.value = {
              top: rect.top,
              left: rect.left,
              width: rect.width,
              height: rect.height,
            };
            guidedTourTargetMissing.value = rect.width <= 0 || rect.height <= 0;
          };

          const refreshGuidedTourHighlight = () => {
            if (!guidedTourActive.value) {
              return;
            }
            nextTick(() => updateGuidedTourHighlightRect());
          };

          const startGuidedTour = () => {
            if (!canStartGuidedTour.value || !guidedTourSteps.value.length) {
              return;
            }
            guidedTourStepIndex.value = 0;
            guidedTourActive.value = true;
            guidedTourTargetMissing.value = false;
            refreshGuidedTourHighlight();
          };

          const closeGuidedTour = () => {
            guidedTourActive.value = false;
            guidedTourHighlightRect.value = null;
            guidedTourTargetMissing.value = false;
          };

          const previousGuidedTourStep = () => {
            if (guidedTourStepIndex.value === 0) {
              return;
            }
            guidedTourStepIndex.value -= 1;
            refreshGuidedTourHighlight();
          };

          const advanceGuidedTour = () => {
            if (isGuidedTourLastStep.value) {
              closeGuidedTour();
              return;
            }
            guidedTourStepIndex.value = Math.min(
              guidedTourStepIndex.value + 1,
              Math.max(0, guidedTourSteps.value.length - 1)
            );
            refreshGuidedTourHighlight();
          };

          const copyToClipboard = async (value) => {
            const text = value == null ? '' : String(value);
            try {
              await navigator.clipboard.writeText(text);
            } catch (error) {
              const textarea = document.createElement('textarea');
              textarea.value = text;
              textarea.style.position = 'fixed';
              textarea.style.opacity = '0';
              textarea.style.pointerEvents = 'none';
              document.body.appendChild(textarea);
              textarea.focus();
              textarea.select();
              try {
                document.execCommand('copy');
              } finally {
                textarea.remove();
              }
            }
          };

          const updateChatThreadHeight = () => {
            chatThreadHeight.value = chatThreadRef.value?.clientHeight || 0;
          };

          const updateViewportWidth = () => {
            viewportWidth.value = typeof window !== 'undefined' ? window.innerWidth : viewportWidth.value;
          };

          const handleWindowResize = () => {
            updateChatThreadHeight();
            updateViewportWidth();
            refreshGuidedTourHighlight();
          };

          const handleGuidedTourScroll = () => {
            if (guidedTourActive.value) {
              updateGuidedTourHighlightRect();
            }
          };

          const scrollElementToBottom = (elementRef) => {
            nextTick(() => {
              const target = elementRef?.value;
              if (target) {
                target.scrollTop = target.scrollHeight;
              }
            });
          };

          const scrollChatThreadToBottom = () => {
            scrollElementToBottom(chatThreadRef);
          };

          const scrollLiveStreamToBottom = () => {
            scrollElementToBottom(liveStreamScrollRef);
          };

          watch(
            () => chatThreadRef.value,
            (element) => {
              if (chatThreadResizeObserver) {
                chatThreadResizeObserver.disconnect();
                chatThreadResizeObserver = null;
              }
              if (element && typeof ResizeObserver !== 'undefined') {
                chatThreadResizeObserver = new ResizeObserver(() => updateChatThreadHeight());
                chatThreadResizeObserver.observe(element);
              }
              nextTick(() => updateChatThreadHeight());
            },
            { immediate: true }
          );

          watch(attemptLogs, () => {
            scrollChatThreadToBottom();
          });

          watch(
            () => selectedPrompt.value?.prompt_id,
            () => {
              nextTick(() => {
                updateChatThreadHeight();
              });
            }
          );

          watch(
            () => selectedPrompt.value?.prompt_id,
            (promptId, previousId) => {
              if (
                editPromptDialogVisible.value &&
                (promptId !== previousId || !promptId)
              ) {
                clearEditPromptState();
              }
            }
          );

          watch(
            () => selectedPrompt.value?.status,
            () => {
              if (editPromptDialogVisible.value && !canEditSelectedPrompt.value) {
                clearEditPromptState();
              }
            }
          );

          watch(showLiveStream, (visible) => {
            nextTick(() => {
              updateChatThreadHeight();
            });
            if (visible) {
              scrollLiveStreamToBottom();
            }
          });

          watch(
            () => [activeStream.value?.stdout, activeStream.value?.stderr],
            () => {
              scrollChatThreadToBottom();
              scrollLiveStreamToBottom();
            }
          );

          watch(
            isAuthenticated,
            (authed) => {
              if (authed) {
                fetchProgressLog();
                startLogRefresh();
                fetchHumanTasks({ silent: true }).catch(() => {});
              } else {
                stopLogRefresh();
                operationsLog.value = '';
                logLastUpdated.value = '';
                logError.value = '';
                logLoading.value = false;
                activeView.value = 'queue';
                resetSettingsState();
              humanTasks.value = [];
              humanTasksSummary.value = {};
              humanTasksRevision.value = null;
              humanTasksError.value = '';
              humanTasksLoading.value = false;
              humanTaskReplyTarget.value = null;
              expandedHumanTaskDescriptions.value = {};
            }
          },
          { immediate: true }
        );

          watch(
            () => [isAuthenticated.value, route.name, route.params.promptId],
            async ([authed, routeName, routePrompt]) => {
              if (!authed || routeName !== 'queue') {
                return;
              }
              const normalizedId = normalizePromptId(routePrompt).trim();
              if (!normalizedId) {
                if (selectedPrompt.value) {
                  selectedPrompt.value = null;
                }
                return;
              }
              if (selectedPrompt.value?.prompt_id === normalizedId) {
                return;
              }
              try {
                await selectPrompt(normalizedId, { updateRoute: false });
              } catch (error) {
                console.error('Unable to restore prompt from route', error);
              }
            },
            { immediate: true }
          );

          const fetchProjects = async () => {
            try {
              const data = await api('/api/projects');
              const items = Array.isArray(data?.projects) ? data.projects : [];
              projectOptions.value = items;
              defaultProjectId.value = data?.default_project_id || null;
              applyProjectSelection();
            } catch (error) {
              console.error('Unable to load projects', error);
              projectOptions.value = [];
              defaultProjectId.value = null;
              selectedProjectId.value = '';
            }
          };

          const fetchPrompts = async (options = {}) => {
            if (!isAuthenticated.value) {
              loading.value = false;
              return;
            }
            const { silent = false } = options;
            if (!silent) {
              loading.value = true;
            }
            try {
              const data = await api('/api/prompts');
              applyQueueSnapshot(data);
            } catch (error) {
              console.error(error);
            } finally {
              if (!silent) {
                loading.value = false;
              }
            }
          };

          const fetchHumanTasks = async (options = {}) => {
            if (!isAuthenticated.value) {
              return;
            }
            const { silent = false } = options;
            if (!silent) {
              humanTasksLoading.value = true;
            }
            humanTasksError.value = '';
            try {
              const data = await api('/api/human_tasks');
              const items = Array.isArray(data?.tasks) ? data.tasks : [];
              humanTasks.value = items;
              if (
                humanTaskReplyTarget.value &&
                !items.some((task) => task.task_id === humanTaskReplyTarget.value?.task_id)
              ) {
                humanTaskReplyTarget.value = null;
              }
              if (data?.summary) {
                humanTasksSummary.value = data.summary;
              }
              const revisionValue =
                typeof data?.revision === 'number'
                  ? data.revision
                  : typeof data?.summary?.revision === 'number'
                    ? data.summary.revision
                    : null;
              if (revisionValue != null) {
                humanTasksRevision.value = revisionValue;
              }
            } catch (error) {
              humanTasksError.value = error.message || 'Unable to load human tasks';
            } finally {
              if (!silent) {
                humanTasksLoading.value = false;
              }
            }
          };

          const fetchEnvironments = async (options = {}) => {
            if (!isAuthenticated.value) {
              return;
            }
            const { silent = false } = options;
            if (!silent) {
              environmentLoading.value = true;
            }
            environmentError.value = '';
            try {
              const data = await api('/api/environments');
              const items = Array.isArray(data?.environments) ? data.environments : [];
              environmentRecords.value = items;
              const revisionValue = typeof data?.revision === 'number' ? data.revision : null;
              if (revisionValue != null) {
                environmentRevision.value = revisionValue;
              }
              environmentLastFetched.value = new Date().toISOString();
            } catch (error) {
              environmentError.value = error.message || 'Unable to load environments';
            } finally {
              if (!silent) {
                environmentLoading.value = false;
              }
            }
          };

          const refreshHumanTasks = () => {
            fetchHumanTasks().catch(() => {});
          };

          const refreshEnvironments = () => {
            fetchEnvironments().catch(() => {});
          };

          const updateClearingHumanTaskState = (taskId, isClearing) => {
            if (!taskId) {
              return;
            }
            const next = new Set(clearingHumanTaskIds.value);
            if (isClearing) {
              next.add(taskId);
            } else {
              next.delete(taskId);
            }
            clearingHumanTaskIds.value = next;
          };

          const isClearingHumanTask = (taskId) => {
            if (!taskId) {
              return false;
            }
            return clearingHumanTaskIds.value.has(taskId);
          };

          const clearHumanTasks = async () => {
            if (
              !isAuthenticated.value ||
              clearHumanTasksLoading.value ||
              hasActiveHumanTaskClear.value
            ) {
              return;
            }
            if (!humanTaskEntries.value.length) {
              return;
            }
            let confirmed = true;
            if (typeof window !== 'undefined' && window.confirm) {
              confirmed = window.confirm('Clear all human tasks? This cannot be undone.');
            }
            if (!confirmed) {
              return;
            }
            clearHumanTasksLoading.value = true;
            humanTasksError.value = '';
            try {
              await api('/api/human_tasks', { method: 'DELETE' });
              await fetchHumanTasks({ silent: true });
            } catch (error) {
              humanTasksError.value = error.message || 'Unable to clear human tasks';
            } finally {
              clearHumanTasksLoading.value = false;
            }
          };

          const clearSingleHumanTask = async (taskId) => {
            if (
              !isAuthenticated.value ||
              !taskId ||
              isClearingHumanTask(taskId) ||
              clearHumanTasksLoading.value
            ) {
              return;
            }
            updateClearingHumanTaskState(taskId, true);
            humanTasksError.value = '';
            try {
              await api(`/api/human_tasks/${encodeURIComponent(taskId)}`, { method: 'DELETE' });
              await fetchHumanTasks({ silent: true });
            } catch (error) {
              humanTasksError.value = error.message || 'Unable to clear human task';
            } finally {
              updateClearingHumanTaskState(taskId, false);
            }
          };

          const startHumanTaskReply = (task) => {
            if (!isAuthenticated.value || !task || !task.task_id) {
              return;
            }
            humanTaskReplyTarget.value = { ...task };
            humanTasksMenuOpen.value = false;
            if (isMobileLayout.value) {
              activeMobilePanel.value = 'queue';
            }
          };

          const reviewProjectHumanTasks = (projectId) => {
            if (!projectId) {
              humanTasksMenuOpen.value = true;
              return;
            }
            const bucket = projectTaskLookup.value.get(projectId);
            if (bucket?.tasks?.length) {
              const target = bucket.tasks.find((task) => task.blocking) || bucket.tasks[0];
              if (target) {
                startHumanTaskReply(target);
                return;
              }
            }
            humanTasksMenuOpen.value = true;
          };

          const clearHumanTaskReply = () => {
            humanTaskReplyTarget.value = null;
          };

          watch(
            () => humanTasksMenuOpen.value,
            (isOpen) => {
              if (isOpen) {
                fetchHumanTasks({ silent: true }).catch(() => {});
              }
            }
          );

          const fetchHealth = async () => {
            if (!isAuthenticated.value) {
              return;
            }
            try {
              const data = await api('/api/health');
              health.value = data;
              if (data?.user) {
                currentUser.value = data.user;
              }
              applyHumanTaskMetrics(data?.metrics?.human_tasks);
              applyEnvironmentMetrics(data?.metrics?.environments);
            } catch (error) {
              console.error(error);
            }
          };

          const applyHumanTaskMetrics = (metrics) => {
            if (!metrics || typeof metrics !== 'object') {
              return;
            }
            humanTasksSummary.value = { ...metrics };
            const revision = typeof metrics.revision === 'number' ? metrics.revision : null;
            if (!isAuthenticated.value) {
              return;
            }
            if (revision == null) {
              return;
            }
            if (humanTasksRevision.value == null) {
              humanTasksRevision.value = revision;
              fetchHumanTasks({ silent: true }).catch(() => {});
              return;
            }
            if (revision !== humanTasksRevision.value) {
              humanTasksRevision.value = revision;
              fetchHumanTasks({ silent: true }).catch(() => {});
            }
          };

          const applyEnvironmentMetrics = (metrics) => {
            if (!metrics || typeof metrics !== 'object') {
              return;
            }
            if (!isAuthenticated.value) {
              return;
            }
            const revision = typeof metrics.revision === 'number' ? metrics.revision : null;
            if (revision == null) {
              return;
            }
            if (environmentRevision.value == null || revision !== environmentRevision.value) {
              environmentRevision.value = revision;
              fetchEnvironments({ silent: true }).catch(() => {});
            }
          };

          const fetchProgressLog = async (options = {}) => {
            if (!isAuthenticated.value) {
              return;
            }
            const { silent = false } = options;
            if (!silent) {
              logLoading.value = true;
            }
            logError.value = '';
            try {
              const data = await api('/api/logs');
              const rawLog = data?.log || '';
              const lines = rawLog ? rawLog.split(/\r?\n/) : [];
              while (lines.length && lines[lines.length - 1] === '') {
                lines.pop();
              }
              operationsLog.value = lines.reverse().join('\n');
              logLastUpdated.value = new Date().toISOString();
            } catch (error) {
              logError.value = error.message || 'Unable to load progress log';
            } finally {
              if (!silent) {
                logLoading.value = false;
              }
            }
          };

          const startLogRefresh = () => {
            clearLogRefreshTimer();
            if (!isAuthenticated.value) {
              return;
            }
            logRefreshTimer = setInterval(() => {
              fetchProgressLog({ silent: true }).catch(() => {});
            }, LOG_REFRESH_INTERVAL_MS);
          };

          const refreshProgressLog = () => {
            fetchProgressLog();
          };

          const changePassword = async () => {
            if (!isAuthenticated.value || passwordChangeLoading.value) {
              return;
            }
            if (!passwordForm.current || !passwordForm.newValue || !passwordForm.confirm) {
              passwordChangeError.value = 'All password fields are required';
              passwordChangeSuccess.value = '';
              return;
            }
            if (passwordForm.newValue !== passwordForm.confirm) {
              passwordChangeError.value = 'New password and confirmation do not match';
              passwordChangeSuccess.value = '';
              return;
            }
            if (passwordForm.newValue.length < 8) {
              passwordChangeError.value = 'New password must be at least 8 characters';
              passwordChangeSuccess.value = '';
              return;
            }
            if (passwordForm.newValue === passwordForm.current) {
              passwordChangeError.value = 'New password must be different from the current password';
              passwordChangeSuccess.value = '';
              return;
            }
            passwordChangeError.value = '';
            passwordChangeSuccess.value = '';
            passwordChangeLoading.value = true;
            try {
              await api('/api/user/password', {
                method: 'POST',
                body: JSON.stringify({
                  current_password: passwordForm.current,
                  new_password: passwordForm.newValue,
                }),
              });
              passwordChangeSuccess.value = 'Password updated successfully.';
              resetPasswordForm();
            } catch (error) {
              passwordChangeError.value = error.message || 'Unable to change password';
            } finally {
              passwordChangeLoading.value = false;
            }
          };

          const fetchSshKeys = async () => {
            if (!isAuthenticated.value) {
              return;
            }
            sshKeysLoading.value = true;
            sshKeysError.value = '';
            try {
              const response = await api('/api/user/ssh_keys');
              const items = Array.isArray(response?.keys) ? response.keys : [];
              sshKeys.value = items;
              sshKeysLastFetched.value = new Date().toISOString();
            } catch (error) {
              sshKeys.value = [];
              sshKeysError.value = error.message || 'Unable to load SSH keys';
            } finally {
              sshKeysLoading.value = false;
            }
          };

          watch(
            () => activeView.value,
            (view) => {
              if (view === 'settings') {
                fetchSshKeys();
              }
            }
          );

          const submitPrompt = async () => {
            if (!isAuthenticated.value || !promptText.value.trim()) return;
            submitting.value = true;
            try {
              const payload = { prompt: promptText.value };
              if (activeProjectId.value) {
                payload.project_id = activeProjectId.value;
              }
              if (humanTaskReplyTarget.value?.task_id) {
                payload.human_task_id = humanTaskReplyTarget.value.task_id;
              }
              const response = await api('/api/prompts', {
                method: 'POST',
                body: JSON.stringify(payload),
              });
              promptText.value = '';
              if (humanTaskReplyTarget.value) {
                humanTaskReplyTarget.value = null;
              }
              if (response?.prompt_id) {
                await selectPrompt({ prompt_id: response.prompt_id });
              }
              if (!realtimeReady.value) {
                await fetchPrompts({ silent: true });
              }
            } catch (error) {
              alert(error.message);
            } finally {
              submitting.value = false;
            }
          };

          const handleComposerKeydown = (event) => {
            if (event.shiftKey) {
              return;
            }
            event.preventDefault();
            if (!promptText.value.trim() || submitting.value) {
              return;
            }
            submitPrompt();
          };

          const refreshSelectedPrompt = async (promptId) => {
            if (!isAuthenticated.value) return;
            const targetId = promptId || selectedPrompt.value?.prompt_id;
            if (!targetId) return;
            if (realtimeReady.value && sendRealtimeMessage({ type: 'fetch_prompt', prompt_id: targetId })) {
              return;
            }
            try {
              const data = await api(`/api/prompts/${targetId}`);
              if (!selectedPrompt.value || selectedPrompt.value.prompt_id === targetId) {
                selectedPrompt.value = data;
              }
            } catch (error) {
              console.error(error);
            }
          };

          const selectPrompt = async (prompt, options = {}) => {
            if (!prompt) return;
            const { updateRoute = true } = options;
            const promptId =
              typeof prompt === 'string' ? normalizePromptId(prompt) : normalizePromptId(prompt.prompt_id);
            if (!promptId) {
              return;
            }
            const matchingEntry =
              typeof prompt === 'object' && prompt.prompt_id
                ? prompt
                : queue.value.find((item) => item.prompt_id === promptId);
            if (!selectedPrompt.value || selectedPrompt.value.prompt_id !== promptId) {
              selectedPrompt.value = matchingEntry ? { ...matchingEntry } : { prompt_id: promptId };
            } else if (matchingEntry) {
              selectedPrompt.value = { ...selectedPrompt.value, ...matchingEntry };
            }
            if (updateRoute && route.params.promptId !== promptId) {
              router.replace({ name: 'queue', params: { promptId } }).catch(() => {});
            }
            await refreshSelectedPrompt(promptId);
            if (isMobileLayout.value) {
              activeMobilePanel.value = 'thread';
            }
          };

          const queuePromptRetry = async (stateRef, errorMessage) => {
            const currentId = selectedPrompt.value?.prompt_id;
            if (!currentId || stateRef.value) {
              return;
            }
            stateRef.value = true;
            try {
              await api(`/api/prompts/${currentId}/retry`, { method: 'POST' });
              if (!realtimeReady.value) {
                await fetchPrompts({ silent: true });
              }
              const refreshed = queue.value.find((item) => item.prompt_id === currentId) || { prompt_id: currentId };
              await selectPrompt(refreshed);
            } catch (error) {
              alert(error.message || errorMessage);
            } finally {
              stateRef.value = false;
            }
          };

          const retryPrompt = async () => {
            if (!isAuthenticated.value || !selectedPrompt.value) return;
            await queuePromptRetry(retrying, 'Unable to retry prompt');
          };

          const restartSelectedPrompt = async () => {
            if (!isAuthenticated.value || !selectedPrompt.value || !canRestartSelectedPrompt.value) {
              return;
            }
            await queuePromptRetry(restarting, 'Unable to restart prompt');
          };

          const performCancelAction = async () => {
            if (!isAuthenticated.value || !selectedPrompt.value || !canCancelSelectedPrompt.value) {
              return;
            }
            if (canceling.value) {
              return;
            }
            const status = (selectedPrompt.value.status || '').toLowerCase();
            if (status === 'queued') {
              const confirmed =
                typeof window === 'undefined' ? true : window.confirm('Cancel this queued prompt?');
              if (!confirmed) {
                return;
              }
            }
            canceling.value = true;
            const promptId = selectedPrompt.value.prompt_id;
            try {
              if (status === 'queued') {
                await api(`/api/prompts/${promptId}`, { method: 'DELETE' });
                const index = queue.value.findIndex((entry) => entry.prompt_id === promptId);
                if (index !== -1) {
                  queue.value.splice(index, 1);
                  refreshLocalQueueStatusBuckets();
                }
                clearStreamState(promptId);
                selectedPrompt.value = null;
                router.replace({ name: 'queue' }).catch(() => {});
              } else {
                await api(`/api/prompts/${promptId}/cancel`, {
                  method: 'POST',
                  body: JSON.stringify({ restart: false }),
                });
              }
              if (!realtimeReady.value) {
                await fetchPrompts({ silent: true });
              }
            } catch (error) {
              const fallbackMessage = status === 'queued' ? 'Unable to delete prompt' : 'Unable to cancel prompt';
              alert(error.message || fallbackMessage);
            } finally {
              canceling.value = false;
            }
          };

          const cancelSelectedPrompt = () => performCancelAction();

          const clearEditPromptState = () => {
            editPromptDialogVisible.value = false;
            editPromptText.value = '';
            editPromptError.value = '';
          };

          const openEditPromptDialog = () => {
            if (!canEditSelectedPrompt.value || !selectedPrompt.value) {
              return;
            }
            editPromptText.value = selectedPrompt.value.text || '';
            editPromptError.value = '';
            editPromptDialogVisible.value = true;
          };

          const cancelEditPrompt = () => {
            if (editPromptSaving.value) {
              return;
            }
            clearEditPromptState();
          };

          const savePromptEdit = async () => {
            if (!isAuthenticated.value || !canEditSelectedPrompt.value || !selectedPrompt.value) {
              return;
            }
            const trimmed = editPromptText.value.trim();
            if (!trimmed) {
              editPromptError.value = 'Prompt text is required';
              return;
            }
            editPromptSaving.value = true;
            editPromptError.value = '';
            try {
              const response = await api(`/api/prompts/${selectedPrompt.value.prompt_id}`, {
                method: 'PUT',
                body: JSON.stringify({ prompt: trimmed }),
              });
              const updated = response?.prompt;
              if (updated && updated.prompt_id === selectedPrompt.value.prompt_id) {
                selectedPrompt.value = { ...selectedPrompt.value, ...updated };
              } else {
                selectedPrompt.value = { ...(selectedPrompt.value || {}), text: trimmed };
              }
              const queueIndex = queue.value.findIndex(
                (entry) => entry.prompt_id === selectedPrompt.value?.prompt_id
              );
              if (queueIndex !== -1) {
                const replacement = { ...queue.value[queueIndex], text: trimmed };
                queue.value.splice(queueIndex, 1, replacement);
                refreshLocalQueueStatusBuckets();
              }
              if (!realtimeReady.value) {
                await fetchPrompts({ silent: true });
              }
              clearEditPromptState();
            } catch (error) {
              editPromptError.value = error.message || 'Unable to update prompt';
            } finally {
              editPromptSaving.value = false;
            }
          };

          const login = async () => {
            const email = loginEmail.value.trim();
            if (loginLoading.value) {
              return;
            }
            if (!email || !loginPassword.value) {
              loginError.value = 'Email and password are required';
              return;
            }
            loginLoading.value = true;
            loginError.value = '';
            try {
              const response = await fetch('/api/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ email, password: loginPassword.value }),
              });
              const payload = await response.json().catch(() => ({}));
              if (!response.ok) {
                throw new Error(payload.error || 'Unable to sign in');
              }
              if (!payload.token) {
                throw new Error('Login response missing token');
              }
              authToken.value = payload.token;
              currentUser.value = payload.user || { email };
              loginPassword.value = '';
              persistToken(payload.token);
              connectRealtime();
              await fetchPrompts();
              await fetchHealth();
              await fetchHumanTasks();
              await fetchEnvironments({ silent: true });
            } catch (error) {
              handleUnauthorized();
              loginError.value = error.message || 'Unable to sign in';
            } finally {
              loginLoading.value = false;
            }
          };

          const togglePasswordVisibility = () => {
            showPassword.value = !showPassword.value;
          };

          const logout = () => {
            handleUnauthorized();
            loginPassword.value = '';
            loginError.value = '';
          };

          const persistThemePreference = async (mode) => {
            const normalized = mode === 'dark' ? 'dark' : mode === 'light' ? 'light' : '';
            if (!normalized || typeof fetch === 'undefined') {
              return;
            }
            const headers = { 'Content-Type': 'application/json' };
            if (authToken.value) {
              headers.Authorization = `Bearer ${authToken.value}`;
            }
            try {
              await fetch('/api/preferences/theme', {
                method: 'PUT',
                headers,
                body: JSON.stringify({ mode: normalized }),
              });
            } catch (error) {
              console.warn('Unable to sync server theme preference', error);
            }
          };

          const updateFaviconLinks = (mode) => {
            if (typeof document === 'undefined') {
              return;
            }
            const sources = FAVICON_SOURCES[mode] || FAVICON_SOURCES.dark;
            Object.entries(sources).forEach(([variant, config]) => {
              if (!config) {
                return;
              }
              const link = document.querySelector(`link[data-nightshift-favicon='${variant}']`);
              if (!link) {
                return;
              }
              link.setAttribute('href', config.href);
              link.setAttribute('type', config.type);
              if (config.sizes) {
                link.setAttribute('sizes', config.sizes);
              } else {
                link.removeAttribute('sizes');
              }
            });
          };

          const applyTheme = (mode) => {
            themeMode.value = mode;
            theme.global.name.value = mode;
            if (typeof document !== 'undefined') {
              document.documentElement.setAttribute('data-theme', mode);
            }
            updateFaviconLinks(mode);
            if (typeof window !== 'undefined' && window.localStorage) {
              try {
                window.localStorage.setItem(THEME_STORAGE_KEY, mode);
              } catch (error) {
                console.warn('Unable to persist theme preference', error);
              }
            }
            persistThemePreference(mode);
          };

          const initTheme = () => {
            let preferred = themeMode.value;
            if (typeof window !== 'undefined' && window.localStorage) {
              try {
                const stored = window.localStorage.getItem(THEME_STORAGE_KEY);
                if (stored === 'light' || stored === 'dark') {
                  preferred = stored;
                }
              } catch (error) {
                console.warn('Unable to read stored theme preference', error);
              }
            }
            applyTheme(preferred);
          };

          const toggleTheme = () => {
            const next = themeMode.value === 'dark' ? 'light' : 'dark';
            applyTheme(next);
          };

          onMounted(async () => {
            initTheme();
            if (!elapsedTimer) {
              elapsedTimer = setInterval(() => {
                nowTick.value = Date.now();
              }, 1000);
            }
            fetchProjects().catch(() => {});
            if (typeof window !== 'undefined') {
              updateViewportWidth();
              window.addEventListener('resize', handleWindowResize);
              window.addEventListener('scroll', handleGuidedTourScroll, true);
            }
            if (typeof window !== 'undefined' && window.localStorage) {
              try {
                const storedToken = window.localStorage.getItem(AUTH_TOKEN_KEY);
                if (storedToken) {
                  authToken.value = storedToken;
                  connectRealtime();
                  await fetchPrompts({ silent: true });
                  await fetchHealth();
                  await fetchHumanTasks({ silent: true });
                  await fetchEnvironments({ silent: true });
                  loading.value = false;
                  return;
                }
              } catch (error) {
                console.warn('Unable to restore auth token', error);
              }
            }
            loading.value = false;
          });

          onUnmounted(() => {
            disconnectRealtime({ manual: true });
            stopLogRefresh();
            if (elapsedTimer) {
              clearInterval(elapsedTimer);
              elapsedTimer = null;
            }
            if (chatThreadResizeObserver) {
              chatThreadResizeObserver.disconnect();
              chatThreadResizeObserver = null;
            }
            if (typeof window !== 'undefined') {
              window.removeEventListener('resize', handleWindowResize);
              window.removeEventListener('scroll', handleGuidedTourScroll, true);
            }
          });

          return {
            promptText,
            queue,
            queueEntries,
            projectOptions,
            projectSearch,
            projectDirectoryEntries,
            projectDirectorySummary,
            selectedProjectId,
            activeProjectLaunchUrl,
            activeProjectId,
            canEditSelectedPrompt,
            canRestartSelectedPrompt,
            selectedPrompt,
            isMobileLayout,
            activeMobilePanel,
            mobileComposerExpanded,
            workspacePanelCollapsed,
            loading,
            submitting,
            health,
            environmentLoading,
            environmentError,
            environmentLastFetched,
            refreshEnvironments,
            getHealthStatusColor,
            getLifecycleStatusColor,
            codexStatusInfo,
            humanTaskEntries,
            humanTasksLoading,
            clearHumanTasksLoading,
            hasActiveHumanTaskClear,
            humanTasksError,
            humanTasksBadgeState,
            humanTasksMenuLabel,
            humanTasksMenuOpen,
            humanTaskReplyTarget,
            toggleHumanTaskDescription,
            isHumanTaskDescriptionExpanded,
            blockingHumanTaskCount,
            openHumanTaskCount,
            refreshHumanTasks,
            clearHumanTasks,
            clearSingleHumanTask,
            startHumanTaskReply,
            reviewProjectHumanTasks,
            clearHumanTaskReply,
            isClearingHumanTask,
            retrying,
            canceling,
            restarting,
            formatDate,
            submitPrompt,
            selectPrompt,
            retryPrompt,
            canCancelSelectedPrompt,
            cancelSelectedPrompt,
            restartSelectedPrompt,
            copyToClipboard,
            attemptLogs,
            attemptKey,
            globalContext,
            selectedPromptProjectName,
            activeStream,
            showLiveStream,
            liveAttemptNumber,
            liveAttemptReceivedAt,
            liveAttemptDurationSeconds,
            activeView,
            openSettingsView,
            returnToQueueView,
            goHome,
            showQueuePanel,
            showThreadPanel,
            showWorkspacePanel,
            toggleWorkspacePanel,
            toggleMobileComposer,
            startGuidedTour,
            closeGuidedTour,
            previousGuidedTourStep,
            advanceGuidedTour,
            guidedTourVisible,
            guidedTourHighlightStyle,
            guidedTourStepNumber,
            guidedTourTotalSteps,
            guidedTourCurrentStep,
            guidedTourTargetMissing,
            isGuidedTourLastStep,
            canStartGuidedTour,
            passwordForm,
            passwordChangeLoading,
            passwordChangeError,
            passwordChangeSuccess,
            sshKeys,
            sshKeysLoading,
            sshKeysError,
            sshKeysLastFetched,
            canSubmitPassword,
            changePassword,
            fetchSshKeys,
            themeMode,
            headerIconSrc,
            toggleTheme,
            chatThreadRef,
            liveStreamScrollRef,
            formatTimestamp,
            formatDuration,
            formatStatus,
            formatQueueBadgeCount,
            formatHumanTaskReference,
            handleComposerKeydown,
            isAuthenticated,
            loginEmail,
            loginPassword,
            showPassword,
            togglePasswordVisibility,
            loginLoading,
            loginError,
            login,
            logout,
            currentUser,
            wsStatus,
            operationsLog,
            logLoading,
            logError,
            logLastUpdated,
            refreshProgressLog,
            parseOutputSegments,
            editPromptDialogVisible,
            editPromptText,
            editPromptError,
            editPromptSaving,
            openEditPromptDialog,
            cancelEditPrompt,
            savePromptEdit,
          };
        },
        template: `
          <v-app>
            <v-dialog v-model="editPromptDialogVisible" max-width="640">
              <v-card>
                <v-card-title>Edit Prompt</v-card-title>
                <v-card-text>
                  <p class="text-body-2 text-medium-emphasis mb-3">
                    Update the prompt text before rerunning or archiving it.
                  </p>
                  <v-alert v-if="editPromptError" type="error" variant="tonal" class="mb-3">
                    {{ editPromptError }}
                  </v-alert>
                  <v-textarea
                    v-model="editPromptText"
                    variant="outlined"
                    rows="4"
                    auto-grow
                    hide-details
                    placeholder="Revise the prompt text"
                  />
                </v-card-text>
                <v-card-actions>
                  <v-spacer />
                  <v-btn variant="text" :disabled="editPromptSaving" @click="cancelEditPrompt">Cancel</v-btn>
                  <v-btn
                    color="primary"
                    :loading="editPromptSaving"
                    :disabled="editPromptSaving || !editPromptText.trim()"
                    @click="savePromptEdit"
                  >
                    Save
                  </v-btn>
                </v-card-actions>
              </v-card>
            </v-dialog>
              <v-app-bar class="global-header" flat>
                <v-app-bar-title>
                  <div class="global-header__branding">
                    <button
                      type="button"
                      class="global-header__home-link"
                      data-tour-id="tour-home-link"
                      @click="goHome"
                    >
                      <img
                        :src="headerIconSrc"
                        alt="Nightshift"
                        class="global-header__logo"
                        width="36"
                        height="36"
                        title="Return to the main dashboard"
                      />
                      <div class="global-header__text">
                        <span class="global-header__title">Nightshift</span>
                        <span class="global-header__subtitle">all day every day</span>
                      </div>
                    </button>
                    <v-btn
                      v-if="isAuthenticated"
                      class="guided-tour-trigger"
                      variant="tonal"
                      density="compact"
                      size="x-small"
                      prepend-icon="mdi-compass-outline"
                      :title="
                        canStartGuidedTour
                          ? 'Step through what each panel does'
                          : 'Guided tour needs the desktop layout while you are signed in'
                      "
                      :disabled="!canStartGuidedTour"
                      @click="startGuidedTour"
                    >
                      Take tour
                    </v-btn>
                  </div>
                </v-app-bar-title>
                <v-spacer />
                <div
                  v-if="isAuthenticated"
                  class="header-notifications"
                  data-tour-id="tour-human-tasks"
                >
                  <v-menu
                    v-model="humanTasksMenuOpen"
                    location="bottom start"
                    transition="scale-transition"
                    :close-on-content-click="false"
                  >
                    <template #activator="{ props }">
                      <v-badge
                        :model-value="humanTasksBadgeState.showBadge"
                        :content="humanTasksBadgeState.badgeText"
                        :color="humanTasksBadgeState.badgeColor || undefined"
                      >
                        <v-btn
                          v-bind="props"
                          icon
                          variant="text"
                          density="comfortable"
                          class="human-tasks-trigger"
                          :aria-label="humanTasksMenuLabel"
                          :title="humanTasksMenuLabel"
                        >
                          <v-progress-circular
                            v-if="humanTasksLoading && !humanTasksError"
                            indeterminate
                            size="18"
                            width="2"
                          ></v-progress-circular>
                          <span
                            v-else
                            :class="['mdi', humanTasksBadgeState.icon, 'human-tasks-trigger__icon']"
                            aria-hidden="true"
                          ></span>
                        </v-btn>
                      </v-badge>
                    </template>
                    <v-card class="human-tasks-dropdown" elevation="10">
                      <div class="human-tasks-panel">
                        <div class="human-tasks-panel__header">
                          <span class="human-tasks-panel__header-title">Human Tasks</span>
                          <div class="human-tasks-panel__badges">
                            <v-chip label size="small" variant="tonal" color="warning">
                              Blocking {{ blockingHumanTaskCount }}
                            </v-chip>
                            <v-chip label size="small" variant="tonal" color="primary">
                              Open {{ openHumanTaskCount }}
                            </v-chip>
                            <v-btn
                              icon="mdi-delete-sweep-outline"
                              size="small"
                              variant="text"
                              color="error"
                              :loading="clearHumanTasksLoading"
                              :disabled="
                                humanTasksLoading ||
                                clearHumanTasksLoading ||
                                hasActiveHumanTaskClear ||
                                !humanTaskEntries.length
                              "
                              @click="clearHumanTasks"
                              aria-label="Clear human tasks"
                              :title="humanTaskEntries.length ? 'Remove all human tasks' : 'No human tasks to clear'"
                            ></v-btn>
                            <v-btn
                              icon="mdi-refresh"
                              size="small"
                              variant="text"
                              :loading="humanTasksLoading"
                              :disabled="humanTasksLoading"
                              @click="refreshHumanTasks"
                              aria-label="Refresh human tasks"
                            ></v-btn>
                          </div>
                        </div>
                        <div class="human-tasks-panel__body">
                          <v-alert
                            v-if="humanTasksError"
                            type="error"
                            variant="tonal"
                            density="comfortable"
                            border="start"
                          >
                            {{ humanTasksError }}
                          </v-alert>
                          <v-skeleton-loader
                            v-else-if="humanTasksLoading && !humanTaskEntries.length"
                            type="list-item@2"
                          />
                          <div v-else-if="humanTaskEntries.length" class="human-tasks-list">
                            <div v-for="task in humanTaskEntries" :key="task.task_id" class="human-task-entry">
                              <div class="human-task-entry__header">
                                <span>{{ task.title }}</span>
                                <div class="human-task-entry__header-actions">
                                  <v-chip
                                    v-if="task.blocking"
                                    size="x-small"
                                    color="error"
                                    variant="tonal"
                                    label
                                  >
                                    Blocking
                                  </v-chip>
                                  <span class="text-caption text-medium-emphasis">
                                    {{ task.statusDisplay }}
                                  </span>
                                  <v-btn
                                    icon="mdi-reply"
                                    size="x-small"
                                    variant="text"
                                    color="primary"
                                    class="human-task-entry__reply-btn"
                                    :disabled="humanTasksLoading || clearHumanTasksLoading"
                                    @click.stop="startHumanTaskReply(task)"
                                    aria-label="Reply to this human task"
                                    :title="'Reply to ' + (task.title || 'task')"
                                  ></v-btn>
                                  <v-btn
                                    icon="mdi-check-circle-outline"
                                    size="x-small"
                                    variant="text"
                                    color="success"
                                    class="human-task-entry__clear-btn"
                                    :loading="isClearingHumanTask(task.task_id)"
                                    :disabled="
                                      humanTasksLoading ||
                                      clearHumanTasksLoading ||
                                      isClearingHumanTask(task.task_id)
                                    "
                                    @click="clearSingleHumanTask(task.task_id)"
                                    aria-label="Clear this human task"
                                    :title="'Clear ' + (task.title || 'task')"
                                  ></v-btn>
                                </div>
                              </div>
                              <div class="human-task-entry__meta">
                                <span>{{ task.projectDisplay }}</span>
                                <span v-if="task.prompt_id">Prompt #{{ task.prompt_id }}</span>
                                <span>{{ formatTimestamp(task.updated_at) }}</span>
                              </div>
                              <p class="human-task-entry__description">
                                <span>
                                  {{
                                    isHumanTaskDescriptionExpanded(task.task_id)
                                      ? task.descriptionFull
                                      : task.descriptionSnippet
                                  }}
                                </span>
                                <button
                                  v-if="task.descriptionIsTruncated"
                                  type="button"
                                  class="human-task-entry__description-toggle"
                                  @click.stop.prevent="toggleHumanTaskDescription(task.task_id)"
                                  :aria-expanded="isHumanTaskDescriptionExpanded(task.task_id) ? 'true' : 'false'"
                                  :aria-label="
                                    (isHumanTaskDescriptionExpanded(task.task_id) ? 'Collapse' : 'Expand') +
                                    ' human task description'
                                  "
                                >
                                  {{
                                    isHumanTaskDescriptionExpanded(task.task_id) ? 'Show less' : 'Show more'
                                  }}
                                </button>
                              </p>
                            </div>
                          </div>
                          <div
                            v-else
                            class="human-tasks-panel__empty"
                          >
                            No human tasks logged yet — add blockers whenever you need operator help.
                          </div>
                        </div>
                        <div class="human-tasks-panel__footer human-tasks-dropdown__footer">
                          Logged blockers keep operators in the loop.
                        </div>
                      </div>
                    </v-card>
                  </v-menu>
                </div>
                <div class="header-menus">
                  <div v-if="isAuthenticated" class="user-summary" data-tour-id="tour-user-menu">
                    <v-menu location="bottom end" transition="scale-transition">
                      <template #activator="{ props }">
                        <v-btn
                          v-bind="props"
                          variant="text"
                          class="user-menu__activator"
                          density="comfortable"
                        >
                          <span class="user-summary__email">
                            {{ (currentUser && (currentUser.name || currentUser.email)) || 'Signed in' }}
                          </span>
                          <span class="mdi mdi-menu-down" aria-hidden="true"></span>
                        </v-btn>
                      </template>
                      <v-card class="user-menu-card" elevation="8">
                        <v-list density="compact">
                          <v-list-item class="settings-menu-item" @click="openSettingsView">
                            <template #prepend>
                              <span class="user-menu-icon mdi mdi-cog" aria-hidden="true"></span>
                            </template>
                            <v-list-item-title>Settings</v-list-item-title>
                          </v-list-item>
                          <v-divider class="my-1" />
                          <v-list-item class="logout-list-item" @click="logout">
                            <template #prepend>
                              <span class="user-menu-icon mdi mdi-logout" aria-hidden="true"></span>
                            </template>
                            <v-list-item-title>Sign out</v-list-item-title>
                            <template #append>
                              <button
                                class="theme-toggle logout-theme-toggle"
                                type="button"
                                role="switch"
                                :aria-checked="themeMode === 'dark'"
                                :aria-label="themeMode === 'dark' ? 'Switch to light mode' : 'Switch to dark mode'"
                                @click.stop="toggleTheme"
                                @keydown.enter.prevent.stop="toggleTheme"
                                @keydown.space.prevent.stop="toggleTheme"
                              >
                                <span class="theme-toggle__icon mdi mdi-white-balance-sunny" aria-hidden="true"></span>
                                <span class="theme-toggle__icon mdi mdi-weather-night" aria-hidden="true"></span>
                                <span class="theme-toggle__thumb" :class="{ 'theme-toggle__thumb--right': themeMode === 'dark' }">
                                  <span
                                    :class="['mdi', themeMode === 'dark' ? 'mdi-weather-night' : 'mdi-white-balance-sunny']"
                                    aria-hidden="true"
                                  ></span>
                                </span>
                              </button>
                            </template>
                          </v-list-item>
                        </v-list>
                      </v-card>
                    </v-menu>
                  </div>
                  <button
                    v-else
                    class="theme-toggle ml-3 header-theme-toggle"
                    type="button"
                    role="switch"
                    :aria-checked="themeMode === 'dark'"
                    :aria-label="themeMode === 'dark' ? 'Switch to light mode' : 'Switch to dark mode'"
                    @click="toggleTheme"
                    @keydown.enter.prevent="toggleTheme"
                    @keydown.space.prevent="toggleTheme"
                  >
                    <span class="theme-toggle__icon mdi mdi-white-balance-sunny" aria-hidden="true"></span>
                    <span class="theme-toggle__icon mdi mdi-weather-night" aria-hidden="true"></span>
                    <span class="theme-toggle__thumb" :class="{ 'theme-toggle__thumb--right': themeMode === 'dark' }">
                      <span
                        :class="['mdi', themeMode === 'dark' ? 'mdi-weather-night' : 'mdi-white-balance-sunny']"
                        aria-hidden="true"
                      ></span>
                    </span>
                  </button>
                </div>
            </v-app-bar>
            <v-main>
              <v-container v-if="!isAuthenticated" class="login-container" fluid>
                <div class="login-wrapper">
                  <v-card elevation="0" class="panel-card login-card">
                    <v-card-title>Sign In</v-card-title>
                    <v-card-text>
                      <p class="text-body-2 text-medium-emphasis mb-4">
                        Use your email credentials to access the Task queue.
                      </p>
                      <v-alert
                        v-if="loginError"
                        type="error"
                        variant="tonal"
                        border="start"
                        density="comfortable"
                        class="mb-4"
                      >
                        {{ loginError }}
                      </v-alert>
                      <v-text-field
                        v-model="loginEmail"
                        label="Email"
                        type="email"
                        autocomplete="email"
                        prepend-inner-icon="mdi-email"
                        variant="outlined"
                        density="comfortable"
                        hide-details="auto"
                      />
                      <v-text-field
                        v-model="loginPassword"
                        label="Password"
                        :type="showPassword ? 'text' : 'password'"
                        autocomplete="current-password"
                        prepend-inner-icon="mdi-lock"
                        :append-inner-icon="showPassword ? 'mdi-eye-off' : 'mdi-eye'"
                        @click:append-inner="togglePasswordVisibility"
                        variant="outlined"
                        density="comfortable"
                        hide-details="auto"
                        @keydown.enter.prevent="login"
                      />
                    </v-card-text>
                    <v-card-actions>
                      <v-spacer />
                      <v-btn
                        color="primary"
                        :loading="loginLoading"
                        :disabled="!loginEmail || !loginPassword"
                        @click="login"
                      >
                        Sign In
                      </v-btn>
                    </v-card-actions>
                  </v-card>
                </div>
              </v-container>
              <v-container
                v-else-if="activeView === 'settings'"
                class="py-6 main-layout main-layout--settings"
                fluid
              >
                <v-row class="settings-row" justify="center">
                  <v-col cols="12" md="4" lg="4">
                    <v-card elevation="0" class="panel-card">
                      <v-card-title class="d-flex align-center">
                        <div>
                          <div class="text-h6">Settings</div>
                          <div class="text-caption text-medium-emphasis">
                            Manage your account preferences.
                          </div>
                        </div>
                      </v-card-title>
                      <v-divider />
                      <v-card-text data-tour-id="tour-settings-password">
                        <p class="text-body-2 text-medium-emphasis mb-4">
                          Change the password for {{ currentUser ? currentUser.email : 'your account' }}.
                        </p>
                        <v-alert
                          v-if="passwordChangeError"
                          type="error"
                          variant="tonal"
                          border="start"
                          density="comfortable"
                          class="mb-4"
                        >
                          {{ passwordChangeError }}
                        </v-alert>
                        <v-alert
                          v-if="passwordChangeSuccess"
                          type="success"
                          variant="tonal"
                          border="start"
                          density="comfortable"
                          class="mb-4"
                        >
                          {{ passwordChangeSuccess }}
                        </v-alert>
                        <v-text-field
                          v-model="passwordForm.current"
                          label="Current password"
                          type="password"
                          autocomplete="current-password"
                          prepend-inner-icon="mdi-lock"
                          variant="outlined"
                          density="comfortable"
                          hide-details="auto"
                          class="mb-3"
                        />
                        <v-text-field
                          v-model="passwordForm.newValue"
                          label="New password"
                          type="password"
                          autocomplete="new-password"
                          prepend-inner-icon="mdi-lock-check"
                          variant="outlined"
                          density="comfortable"
                          hide-details="auto"
                          class="mb-3"
                        />
                        <v-text-field
                          v-model="passwordForm.confirm"
                          label="Confirm new password"
                          type="password"
                          autocomplete="new-password"
                          prepend-inner-icon="mdi-lock-reset"
                          variant="outlined"
                          density="comfortable"
                          hide-details="auto"
                        />
                      </v-card-text>
                      <v-card-actions>
                        <v-spacer />
                        <v-btn
                          color="primary"
                          :loading="passwordChangeLoading"
                          :disabled="!canSubmitPassword || passwordChangeLoading"
                          @click="changePassword"
                        >
                          Update password
                        </v-btn>
                      </v-card-actions>
                      <v-divider class="mx-4" />
                      <v-card-text data-tour-id="tour-settings-ssh">
                        <div class="d-flex align-center mb-2">
                          <div>
                            <div class="text-subtitle-1">SSH Public Keys</div>
                            <div class="text-body-2 text-medium-emphasis">
                              Add these keys to GitHub or any other git hosting service.
                            </div>
                          </div>
                          <v-spacer />
                          <v-btn
                            variant="text"
                            size="small"
                            :loading="sshKeysLoading"
                            :disabled="sshKeysLoading"
                            icon="mdi-refresh"
                            @click="fetchSshKeys"
                            :aria-label="sshKeysLoading ? 'Refreshing keys' : 'Refresh keys'"
                          ></v-btn>
                        </div>
                        <div class="text-caption text-medium-emphasis mb-4" v-if="sshKeysLastFetched">
                          Last refreshed {{ formatTimestamp(sshKeysLastFetched) }}
                        </div>
                        <v-alert
                          v-if="sshKeysError"
                          type="error"
                          variant="tonal"
                          border="start"
                          density="comfortable"
                          class="mb-4"
                        >
                          {{ sshKeysError }}
                        </v-alert>
                        <v-skeleton-loader
                          v-if="sshKeysLoading && !sshKeys.length && !sshKeysError"
                          type="list-item-two-line@2"
                        />
                        <div v-else class="ssh-key-list">
                          <div v-if="!sshKeys.length" class="text-body-2 text-medium-emphasis">
                            No SSH keys are available yet.
                          </div>
                          <v-sheet
                            v-for="key in sshKeys"
                            :key="key.name"
                            class="ssh-key-item"
                            color="transparent"
                            elevation="0"
                          >
                            <div class="ssh-key-header">
                              <div class="font-weight-medium">{{ key.name }}</div>
                              <v-chip size="x-small" label>{{ key.type }}</v-chip>
                              <v-chip v-if="key.fingerprint" size="x-small" variant="tonal">
                                {{ key.fingerprint }}
                              </v-chip>
                              <v-spacer />
                              <v-btn
                                variant="text"
                                size="small"
                                prepend-icon="mdi-content-copy"
                                @click="copyToClipboard(key.public_key)"
                              >
                                Copy
                              </v-btn>
                            </div>
                            <pre class="ssh-key-text">{{ key.public_key }}</pre>
                          </v-sheet>
                        </div>
                      </v-card-text>
                    </v-card>
                  </v-col>
                  <v-col
                    v-if="isAuthenticated && (!isMobileLayout || activeMobilePanel === 'workspaces')"
                    cols="12"
                    md="8"
                    lg="8"
                    class="workspace-column d-flex flex-column"
                  >
                    <v-card elevation="0" class="panel-card workspace-panel workspace-panel--settings">
                      <v-card-title class="workspace-panel__title">
                        <div>
                          <div class="text-subtitle-1 font-weight-medium">Workspace overview</div>
                          <div class="workspace-panel__summary">
                            Review workspace runtimes without leaving Settings.
                          </div>
                        </div>
                      </v-card-title>
                      <v-divider />
                      <div v-if="isMobileLayout" class="mobile-panel-controls">
                        <v-btn
                          variant="text"
                          size="small"
                          prepend-icon="mdi-format-list-bulleted"
                          @click="showQueuePanel"
                        >
                          Back to queue
                        </v-btn>
                        <v-btn
                          variant="text"
                          size="small"
                          prepend-icon="mdi-forum"
                          :disabled="!selectedPrompt"
                          @click="showThreadPanel"
                        >
                          View task thread
                        </v-btn>
                      </div>
                      <div class="workspace-panel__body">
                          <div class="workspace-panel__section">
                            <div class="workspace-panel__section-header">
                              <div>
                                <div class="text-subtitle-2 font-weight-medium">Workspaces</div>
                                <div class="workspace-panel__summary">{{ projectDirectorySummary }}</div>
                              </div>
                              <v-text-field
                                v-model="projectSearch"
                                variant="outlined"
                                density="compact"
                                hide-details
                                prepend-inner-icon="mdi-magnify"
                                placeholder="Search workspaces"
                              />
                            </div>
                            <div class="workspace-panel__content">
                              <v-alert
                                v-if="environmentError"
                                type="error"
                                variant="tonal"
                                density="comfortable"
                                border="start"
                                class="mb-4"
                              >
                                {{ environmentError }}
                              </v-alert>
                              <div v-if="!projectDirectoryEntries.length" class="text-body-2 text-medium-emphasis">
                                No workspaces match your search.
                              </div>
                              <div v-else class="workspace-directory">
                                <div
                                  v-for="workspace in projectDirectoryEntries"
                                  :key="workspace.id"
                                  class="workspace-directory__item"
                                >
                                  <div class="workspace-directory__header">
                                    <div>
                                      <div class="workspace-directory__name">{{ workspace.name || workspace.id }}</div>
                                      <div class="workspace-directory__description">
                                        {{ workspace.description || 'No description available.' }}
                                      </div>
                                    </div>
                                    <div class="workspace-directory__actions">
                                      <v-chip size="small" label variant="tonal" color="primary">
                                        Runtimes · {{ workspace.environmentCount }}
                                      </v-chip>
                                      <v-chip
                                        v-if="workspace.blockingTasks"
                                        size="small"
                                        label
                                        variant="tonal"
                                        color="error"
                                      >
                                        Blocking · {{ workspace.blockingTasks }}
                                      </v-chip>
                                      <v-chip
                                        v-else-if="workspace.openTasks"
                                        size="small"
                                        label
                                        variant="tonal"
                                        color="warning"
                                      >
                                        Human tasks · {{ workspace.openTasks }}
                                      </v-chip>
                                      <v-btn
                                        v-if="workspace.launch_url"
                                        :href="workspace.launch_url"
                                        target="_blank"
                                        rel="noopener noreferrer"
                                        size="small"
                                        icon="mdi-open-in-new"
                                        variant="text"
                                        :title="'Open ' + (workspace.name || workspace.id) + ' workspace link'"
                                      ></v-btn>
                                    </div>
                                  </div>
                                  <div class="workspace-directory__meta">
                                    <div class="workspace-directory__meta-item" v-if="workspace.runtimeSummary">
                                      <span>Runtimes</span>
                                      <span>{{ workspace.runtimeSummary }}</span>
                                    </div>
                                    <div class="workspace-directory__meta-item" v-if="workspace.primaryContact">
                                      <span>Contact</span>
                                      <span>{{ workspace.primaryContact }}</span>
                                    </div>
                                    <div class="workspace-directory__meta-item" v-if="workspace.sourceSummary">
                                      <span>Sources</span>
                                      <span>{{ workspace.sourceSummary }}</span>
                                    </div>
                                  </div>
                                  <div class="workspace-directory__environments">
                                    <div
                                      v-if="workspace.environments && workspace.environments.length"
                                      class="workspace-environment-list"
                                    >
                                      <div
                                        v-for="environment in workspace.environments"
                                        :key="environment.id"
                                        class="workspace-environment"
                                      >
                                        <div class="workspace-environment__header">
                                          <div>
                                            <div class="workspace-environment__name">{{ environment.name }}</div>
                                            <div class="workspace-environment__subline">
                                              {{ formatStatus(environment.lifecycleState) }} ·
                                              {{ formatStatus(environment.healthStatus) }}
                                              <span v-if="environment.hostDisplay">· {{ environment.hostDisplay }}</span>
                                            </div>
                                          </div>
                                          <div class="workspace-environment__badges">
                                            <v-chip
                                              size="small"
                                              label
                                              variant="tonal"
                                              :color="getHealthStatusColor(environment.healthStatus)"
                                            >
                                              Health · {{ formatStatus(environment.healthStatus) }}
                                            </v-chip>
                                            <v-chip
                                              size="small"
                                              label
                                              variant="tonal"
                                              :color="getLifecycleStatusColor(environment.lifecycleState)"
                                            >
                                              Lifecycle · {{ formatStatus(environment.lifecycleState) }}
                                            </v-chip>
                                            <v-chip
                                              v-if="environment.blockingTasks"
                                              size="small"
                                              label
                                              variant="tonal"
                                              color="error"
                                            >
                                              Blocking · {{ environment.blockingTasks }}
                                            </v-chip>
                                            <v-chip
                                              v-else-if="environment.openTasks"
                                              size="small"
                                              label
                                              variant="tonal"
                                              color="warning"
                                            >
                                              Human tasks · {{ environment.openTasks }}
                                            </v-chip>
                                          </div>
                                        </div>
                                        <div
                                          class="workspace-environment__links"
                                          v-if="environment.quickLinks && environment.quickLinks.length"
                                        >
                                          <v-btn
                                            v-for="link in environment.quickLinks"
                                            :key="link.url"
                                            :href="link.url"
                                            target="_blank"
                                            rel="noopener noreferrer"
                                            variant="tonal"
                                            size="small"
                                            prepend-icon="mdi-launch"
                                          >
                                            {{ link.label }}
                                          </v-btn>
                                        </div>
                                        <div class="workspace-environment__actions">
                                          <v-btn
                                            v-if="environment.primaryLink"
                                            :href="environment.primaryLink"
                                            target="_blank"
                                            rel="noopener noreferrer"
                                            variant="tonal"
                                            size="small"
                                            prepend-icon="mdi-launch"
                                          >
                                            Open
                                          </v-btn>
                                          <v-btn
                                            v-if="environment.projectId && (environment.blockingTasks || environment.openTasks)"
                                            variant="text"
                                            size="small"
                                            density="comfortable"
                                            prepend-icon="mdi-account-question"
                                            @click="reviewProjectHumanTasks(environment.projectId)"
                                          >
                                            Human tasks
                                          </v-btn>
                                          <v-spacer />
                                          <span class="text-caption text-medium-emphasis" v-if="environment.updated_at">
                                            Updated · {{ formatTimestamp(environment.updated_at) }}
                                          </span>
                                        </div>
                                      </div>
                                    </div>
                                    <div
                                      v-else
                                      class="workspace-environment__empty text-body-2 text-medium-emphasis"
                                    >
                                      No runtimes registered yet.
                                    </div>
                                  </div>
                                  <div class="workspace-directory__footer">
                                    <v-btn
                                      v-if="workspace.hasHumanTasks && workspace.id !== '__unscoped__'"
                                      variant="text"
                                      size="small"
                                      density="comfortable"
                                      prepend-icon="mdi-account-question"
                                      @click="reviewProjectHumanTasks(workspace.id)"
                                    >
                                      Review human tasks
                                    </v-btn>
                                  </div>
                            </div>
                          </div>
                            </div>
                          </div>
                      </div>
                    </v-card>
                  </v-col>
                </v-row>
                <v-row class="settings-log-row mt-6">
                  <v-col cols="12">
                    <v-card
                      elevation="0"
                      class="panel-card log-card settings-log-card"
                      data-tour-id="tour-operations-log"
                    >
                      <v-card-title class="log-card__header">
                        <div>
                          <div class="text-h6">Operations Log</div>
                          <div class="text-caption text-medium-emphasis">
                            {{ logLastUpdated ? 'Updated · ' + formatTimestamp(logLastUpdated) : 'Not refreshed yet' }}
                          </div>
                        </div>
                        <div class="log-card__actions">
                          <v-btn
                            icon="mdi-refresh"
                            variant="text"
                            :loading="logLoading"
                            :disabled="logLoading"
                            @click="refreshProgressLog"
                            aria-label="Refresh operations log"
                          ></v-btn>
                        </div>
                      </v-card-title>
                      <v-divider />
                      <v-card-text class="log-card__body">
                        <v-alert
                          v-if="logError"
                          type="error"
                          variant="tonal"
                          density="comfortable"
                          border="start"
                          class="mb-3"
                        >
                          {{ logError }}
                        </v-alert>
                        <v-skeleton-loader v-if="logLoading && !operationsLog" type="paragraph@3" />
                        <div v-else class="log-content" :class="{ 'log-content--empty': !operationsLog }">
                          <pre v-if="operationsLog">{{ operationsLog }}</pre>
                          <span v-else class="log-content__placeholder">
                            No entries in progress log yet.
                          </span>
                        </div>
                      </v-card-text>
                    </v-card>
                  </v-col>
                </v-row>
              </v-container>
              <v-container v-else class="py-6 main-layout" fluid>

                <v-row class="main-row">
                  <v-col
                    v-if="!isMobileLayout || activeMobilePanel === 'queue'"
                    cols="12"
                    md="4"
                    lg="4"
                    class="d-flex flex-column"
                  >
                    <v-card elevation="0" class="panel-card queue-card">
                      <v-card-title class="queue-card-title">
                        <span>Task Queue</span>
                        <v-spacer />
                        <v-chip
                          class="realtime-chip"
                          size="small"
                          label
                          :color="wsStatus === 'open' ? 'success' : wsStatus === 'connecting' ? 'warning' : 'error'"
                          variant="tonal"
                        >
                          Realtime · {{ formatStatus(wsStatus) }}
                        </v-chip>
                      </v-card-title>
                      <v-divider />
                      <div v-if="isMobileLayout" class="mobile-panel-controls">
                        <v-btn
                          variant="tonal"
                          size="small"
                          prepend-icon="mdi-forum"
                          :disabled="!selectedPrompt"
                          @click="showThreadPanel"
                        >
                          View task thread
                        </v-btn>
                        <v-btn
                          variant="text"
                          size="small"
                          prepend-icon="mdi-view-dashboard-outline"
                          @click="showWorkspacePanel"
                        >
                          Workspace overview
                        </v-btn>
                      </div>
                      <div class="workspace-selector" data-tour-id="tour-workspace-selector">
                        <v-select
                          v-model="selectedProjectId"
                          :items="projectOptions"
                          item-title="name"
                          item-value="id"
                          label="Workspace"
                          variant="outlined"
                          density="comfortable"
                          hide-details="auto"
                          :disabled="!projectOptions.length"
                        />
                        <div class="workspace-selector__hint">
                          <a
                            v-if="activeProjectLaunchUrl"
                            class="workspace-selector__live-link"
                            :href="activeProjectLaunchUrl"
                            target="_blank"
                            rel="noopener noreferrer"
                          >
                            <span>{{ activeProjectLaunchUrl }}</span>
                            <span class="mdi mdi-open-in-new" aria-hidden="true"></span>
                          </a>
                          <span
                            v-else
                            class="workspace-selector__live-link workspace-selector__live-link--disabled"
                          >
                            Live endpoint not configured
                          </span>
                        </div>
                      </div>
                      <v-divider />
                      <div
                        class="queue-composer"
                        data-tour-id="tour-prompt-composer"
                        :class="{
                          'queue-composer--mobile': isMobileLayout,
                          'queue-composer--mobile-collapsed': isMobileLayout && !mobileComposerExpanded,
                        }"
                      >
                        <div v-if="isMobileLayout" class="mobile-composer-toggle">
                          <div class="mobile-composer-toggle__text">
                            <div class="mobile-composer-toggle__title">Prompt composer</div>
                            <div class="mobile-composer-toggle__hint">
                              {{ mobileComposerExpanded ? 'Hide input area' : 'Tap to add instructions' }}
                            </div>
                          </div>
                          <v-btn
                            class="mobile-composer-toggle__button"
                            variant="text"
                            density="comfortable"
                            size="small"
                            :prepend-icon="mobileComposerExpanded ? 'mdi-chevron-up' : 'mdi-pencil'"
                            @click="toggleMobileComposer"
                          >
                            {{ mobileComposerExpanded ? 'Hide' : 'Compose' }}
                          </v-btn>
                        </div>
                        <v-expand-transition>
                          <div class="queue-composer__body" v-show="!isMobileLayout || mobileComposerExpanded">
                            <div v-if="humanTaskReplyTarget" class="human-task-reply-banner">
                              <span class="mdi mdi-account-question human-task-reply-banner__icon" aria-hidden="true"></span>
                              <div class="human-task-reply-banner__text">
                                Replying to
                                <strong>{{ formatHumanTaskReference(humanTaskReplyTarget) }}</strong>
                                <span v-if="humanTaskReplyTarget.projectDisplay">
                                  · {{ humanTaskReplyTarget.projectDisplay }}
                                </span>
                              </div>
                              <v-btn
                                class="human-task-reply-banner__clear"
                                variant="text"
                                size="x-small"
                                color="primary"
                                @click="clearHumanTaskReply"
                              >
                                Cancel
                              </v-btn>
                            </div>
                            <v-textarea
                              v-model="promptText"
                              :placeholder="
                                humanTaskReplyTarget
                                  ? 'Reply to ' + formatHumanTaskReference(humanTaskReplyTarget)
                                  : 'Type your next instruction to Nightshift'
                              "
                              variant="outlined"
                              auto-grow
                              rows="3"
                              hide-details
                              @keydown.enter="handleComposerKeydown"
                            />
                            <div class="composer-actions">
                              <div class="text-caption text-medium-emphasis codex-status" v-if="codexStatusInfo">
                                <template v-if="codexStatusInfo.error">
                                  <span class="codex-status__error">{{ codexStatusInfo.error }}</span>
                                </template>
                                <template v-else>
                                  <div class="codex-status__line" v-if="codexStatusInfo.fiveHour">
                                    <span>{{ codexStatusInfo.fiveHour.label }}</span>
                                    <span class="codex-status__value">
                                      {{ codexStatusInfo.fiveHour.value || '—' }}
                                    </span>
                                  </div>
                                  <div class="codex-status__line" v-if="codexStatusInfo.weekly">
                                    <span>{{ codexStatusInfo.weekly.label }}</span>
                                    <span class="codex-status__value">
                                      {{ codexStatusInfo.weekly.value || '—' }}
                                    </span>
                                  </div>
                                </template>
                              </div>
                              <v-btn
                                color="primary"
                                :loading="submitting"
                                :disabled="!promptText.trim()"
                                @click="submitPrompt"
                              >
                                Send
                              </v-btn>
                            </div>
                          </div>
                        </v-expand-transition>
                      </div>
                      <v-divider />
                      <v-card-text class="queue-scroll" data-tour-id="tour-queue-list">
                        <v-skeleton-loader v-if="loading" type="list-item@4" />
                        <div v-else class="queue-list">
                          <button
                            v-for="entry in queueEntries"
                            :key="entry.prompt_id"
                            type="button"
                            class="queue-entry"
                            :class="{ active: selectedPrompt && selectedPrompt.prompt_id === entry.prompt_id }"
                            @click="selectPrompt(entry)"
                          >
                            <div class="queue-entry-header">
                              <span class="queue-entry-index">#{{ entry.queueIndex }}</span>
                              <span
                                class="queue-entry-status"
                                :class="'status-' + ((entry.status || '').toLowerCase())"
                              >
                                {{ formatStatus(entry.status) }}
                              </span>
                              <span class="queue-entry-created">{{ entry.createdDisplay }}</span>
                              <span class="queue-entry-runtime">Time {{ entry.runtimeDisplay || '—' }}</span>
                            </div>
                            <div class="queue-entry-detail">
                              {{ entry.detailLine }}
                            </div>
                            <div
                              v-if="entry.human_task"
                              class="queue-entry-human-task"
                            >
                              <span class="mdi mdi-account-question" aria-hidden="true"></span>
                              <span>Reply to · {{ formatHumanTaskReference(entry.human_task) }}</span>
                            </div>
                          </button>
                          <div v-if="!queueEntries.length" class="text-center text-medium-emphasis py-6">
                            No prompts yet — type a prompt above.
                          </div>
                        </div>
                      </v-card-text>
                    </v-card>
                  </v-col>
                  <v-col
                    v-if="!isMobileLayout || activeMobilePanel === 'thread'"
                    cols="12"
                    md="8"
                    lg="8"
                    class="d-flex flex-column"
                  >
                    <v-card elevation="0" class="panel-card chat-card" data-tour-id="tour-thread-panel">
                      <v-card-title class="chat-card__header justify-space-between align-start">
                        <div class="chat-card__header-main">
                          <div
                            class="chat-card-title__heading"
                            v-if="selectedPrompt"
                          >
                            <div class="chat-card-title__task">
                              <button
                                type="button"
                                class="task-id-button"
                                title="Copy task ID"
                                @click.stop="copyToClipboard(selectedPrompt.prompt_id || '')"
                              >
                                Task {{ selectedPrompt.prompt_id }}
                                <span class="mdi mdi-content-copy" aria-hidden="true"></span>
                              </button>
                              <v-btn
                                v-if="canCancelSelectedPrompt"
                                class="chat-card-title__cancel"
                                :color="(selectedPrompt?.status || '').toLowerCase() === 'queued' ? 'error' : 'warning'"
                                variant="outlined"
                                size="small"
                                :loading="canceling"
                                :disabled="canceling"
                                @click="cancelSelectedPrompt"
                              >
                                Cancel
                              </v-btn>
                            </div>
                            <span
                              v-if="selectedPromptProjectName"
                              class="prompt-workspace-pill"
                            >
                              Workspace · {{ selectedPromptProjectName }}
                            </span>
                          </div>
                          <div
                            class="chat-card-title__heading"
                            v-else
                          >
                            <span
                              v-if="selectedPromptProjectName"
                              class="prompt-workspace-pill"
                            >
                              Workspace · {{ selectedPromptProjectName }}
                            </span>
                          </div>
                          <div class="text-caption text-medium-emphasis chat-card-subtitle" v-if="selectedPrompt">
                            <span class="chat-card-subtitle__attempts">
                              Attempts {{ selectedPrompt.attempts || 0 }}
                            </span>
                          </div>
                          <div class="text-caption text-medium-emphasis" v-else>
                            Select a prompt from the queue to review Nightshift output.
                          </div>
                          <div
                            v-if="selectedPrompt?.human_task"
                            class="chat-card-human-task"
                          >
                            <span class="mdi mdi-account-question" aria-hidden="true"></span>
                            <span>Reply to · {{ formatHumanTaskReference(selectedPrompt.human_task) }}</span>
                          </div>
                        </div>
                        <div class="thread-header__actions">
                          <v-btn
                            v-if="canRestartSelectedPrompt"
                            color="warning"
                            variant="tonal"
                            size="small"
                            :loading="restarting"
                            :disabled="restarting"
                            @click="restartSelectedPrompt"
                          >
                            Restart
                          </v-btn>
                          <v-btn
                            v-if="selectedPrompt && selectedPrompt.status === 'failed'"
                            color="warning"
                            variant="tonal"
                            size="small"
                            :loading="retrying"
                            @click="retryPrompt"
                          >
                            Retry
                          </v-btn>
                        </div>
                      </v-card-title>
                      <v-divider />
                      <div v-if="isMobileLayout" class="mobile-panel-controls">
                        <v-btn
                          variant="tonal"
                          size="small"
                          prepend-icon="mdi-format-list-bulleted"
                          @click="showQueuePanel"
                        >
                          Back to queue
                        </v-btn>
                      </div>
                      <div ref="chatThreadRef" class="chat-thread">
                        <div v-if="!selectedPrompt" class="text-medium-emphasis text-center py-10">
                          Waiting for a prompt selection...
                        </div>
                        <template v-else>
                          <div class="chat-message user">
                            <div class="message-meta message-meta--header">
                              <span>Your prompt</span>
                              <span v-if="selectedPrompt.created_at">
                                Submitted · {{ formatTimestamp(selectedPrompt.created_at) }}
                              </span>
                            </div>
                            <details class="detail-panel">
                              <summary>
                                <span>Context</span>
                                <button
                                  type="button"
                                  class="copy-button"
                                  aria-label="Copy context"
                                  title="Copy context"
                                  @click.stop.prevent="copyToClipboard(globalContext || '')"
                                >
                                  <span class="mdi mdi-content-copy" aria-hidden="true"></span>
                                </button>
                              </summary>
                              <div class="detail-content context-block">
                                {{ globalContext || 'No context recorded for this prompt.' }}
                              </div>
                            </details>
                            <div class="chat-bubble prompt copyable">
                              <div class="prompt-bubble-actions">
                                <button
                                  type="button"
                                  class="copy-button"
                                  aria-label="Copy prompt text"
                                  title="Copy prompt text"
                                  @click.stop="copyToClipboard(selectedPrompt.text || '')"
                                >
                                  <span class="mdi mdi-content-copy" aria-hidden="true"></span>
                                </button>
                                <button
                                  v-if="canEditSelectedPrompt"
                                  type="button"
                                  class="copy-button prompt-edit-button"
                                  aria-label="Edit prompt text"
                                  title="Edit prompt text"
                                  @click.stop="openEditPromptDialog"
                                >
                                  <span class="mdi mdi-pencil" aria-hidden="true"></span>
                                </button>
                              </div>
                              <div class="prompt-text">
                                {{ selectedPrompt.text || 'Prompt text unavailable.' }}
                              </div>
                            </div>
                          </div>
                          <div v-if="showLiveStream">
                            <div class="chat-message codex">
                              <div class="message-meta message-meta--header">
                                <span>Attempt {{ liveAttemptNumber || 'Live' }}</span>
                                <span>Status · {{ formatStatus(selectedPrompt.status) }}</span>
                                <span v-if="liveAttemptReceivedAt">
                                  Received · {{ formatTimestamp(liveAttemptReceivedAt) }}
                                </span>
                                <span v-if="liveAttemptDurationSeconds != null">
                                  Time · {{ formatDuration(liveAttemptDurationSeconds) }}
                                </span>
                              </div>
                              <details v-if="activeStream.stderr" class="detail-panel" open>
                                <summary>
                                  <span>Output</span>
                                  <button
                                    type="button"
                                    class="copy-button"
                                    aria-label="Copy live stderr"
                                    title="Copy live stderr"
                                    @click.stop.prevent="copyToClipboard(activeStream.stderr || '')"
                                  >
                                    <span class="mdi mdi-content-copy" aria-hidden="true"></span>
                                  </button>
                                </summary>
                                <div class="detail-content stderr-block" ref="liveStreamScrollRef">
                                  <template v-for="(segment, segIndex) in parseOutputSegments(activeStream.stderr)">
                                    <div
                                      v-if="segment.type === 'text'"
                                      class="stderr-segment"
                                      :key="'live-stderr-' + segIndex"
                                    >
                                      {{ segment.content }}
                                    </div>
                                    <details
                                      v-else-if="segment.type === 'code'"
                                      class="stderr-code-block"
                                      :key="'live-stderr-code-' + segIndex"
                                    >
                                      <summary class="stderr-code-summary">
                                        <span class="stderr-code-summary__label">
                                          {{ segment.language ? segment.language + ' Code' : 'Code block' }}
                                        </span>
                                        <span class="stderr-code-summary__preview">
                                          {{ segment.preview }}
                                        </span>
                                      </summary>
                                      <pre class="stderr-code-content">{{ segment.content }}</pre>
                                    </details>
                                    <details
                                      v-else-if="segment.type === 'exec' || segment.type === 'file-update'"
                                      class="stderr-exec-block"
                                      :key="'live-stderr-collapse-' + segment.type + '-' + segIndex"
                                    >
                                      <summary class="stderr-code-summary">
                                        <span class="stderr-code-summary__label">
                                          {{ segment.type === 'file-update' ? 'File update' : 'Command output' }}
                                        </span>
                                        <span class="stderr-code-summary__preview">
                                          {{ segment.preview }}
                                        </span>
                                      </summary>
                                      <pre class="stderr-code-content">{{ segment.content }}</pre>
                                    </details>
                                  </template>
                                </div>
                              </details>
                            </div>
                          </div>
                          <div v-if="attemptLogs.length">
                            <div
                              v-for="(attempt, index) in attemptLogs"
                              :key="attemptKey(attempt, index)"
                              class="attempt-entry"
                            >
                              <div class="chat-message codex">
                                <div class="message-meta message-meta--header">
                                  <span>Attempt {{ index + 1 }}</span>
                                  <span>Status · {{ formatStatus(attempt.status || selectedPrompt.status) }}</span>
                                  <span>
                                    Received · {{ formatTimestamp(attempt.received_at || selectedPrompt.created_at) }}
                                  </span>
                                  <span>Time · {{ formatDuration(attempt.duration_seconds) }}</span>
                                </div>
                                <details v-if="attempt.stderr" class="detail-panel">
                                  <summary>
                                    <span>Output</span>
                                    <button
                                      type="button"
                                      class="copy-button"
                                      aria-label="Copy output"
                                      title="Copy output"
                                      @click.stop.prevent="copyToClipboard(attempt.stderr || '')"
                                    >
                                      <span class="mdi mdi-content-copy" aria-hidden="true"></span>
                                    </button>
                                  </summary>
                                  <div class="detail-content stderr-block">
                                    <template v-for="(segment, segIndex) in parseOutputSegments(attempt.stderr)">
                                      <div
                                        v-if="segment.type === 'text'"
                                        class="stderr-segment"
                                        :key="attemptKey(attempt, index) + '-stderr-text-' + segIndex"
                                      >
                                        {{ segment.content }}
                                      </div>
                                      <details
                                        v-else-if="segment.type === 'code'"
                                        class="stderr-code-block"
                                        :key="attemptKey(attempt, index) + '-stderr-code-' + segIndex"
                                      >
                                        <summary class="stderr-code-summary">
                                          <span class="stderr-code-summary__label">
                                            {{ segment.language ? segment.language + ' Code' : 'Code block' }}
                                          </span>
                                          <span class="stderr-code-summary__preview">
                                            {{ segment.preview }}
                                          </span>
                                        </summary>
                                        <pre class="stderr-code-content">{{ segment.content }}</pre>
                                      </details>
                                    <details
                                      v-else-if="segment.type === 'exec' || segment.type === 'file-update'"
                                      class="stderr-exec-block"
                                      :key="attemptKey(attempt, index) + '-stderr-collapse-' + segment.type + '-' + segIndex"
                                    >
                                      <summary class="stderr-code-summary">
                                        <span class="stderr-code-summary__label">
                                          {{ segment.type === 'file-update' ? 'File update' : 'Command output' }}
                                        </span>
                                        <span class="stderr-code-summary__preview">
                                          {{ segment.preview }}
                                        </span>
                                      </summary>
                                      <pre class="stderr-code-content">{{ segment.content }}</pre>
                                      </details>
                                    </template>
                                  </div>
                                </details>
                                <div class="chat-bubble response copyable">
                                  <button
                                    type="button"
                                    class="copy-button copy-button--floating"
                                    aria-label="Copy reply body"
                                    title="Copy reply body"
                                    @click.stop="copyToClipboard(attempt.stdout || attempt.summary || '')"
                                  >
                                    <span class="mdi mdi-content-copy" aria-hidden="true"></span>
                                  </button>
                                  <div :class="['stdout-block', { 'stdout-empty': !attempt.stdout }]">
                                    {{ attempt.stdout || attempt.summary || 'No stdout recorded yet.' }}
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                          <div v-else-if="!showLiveStream" class="text-medium-emphasis text-center py-10">
                            No Nightshift output captured for this prompt yet.
                          </div>
                        </template>
                      </div>
                      <div v-if="selectedPrompt" class="detail-footer">
                        <span>Created {{ formatDate(selectedPrompt.created_at) }}</span>
                        <span>Updated {{ formatDate(selectedPrompt.updated_at) }}</span>
                        <span>Status {{ selectedPrompt.status }}</span>
                      </div>
                    </v-card>
                  </v-col>
                </v-row>
              </v-container>
            </v-main>
            <router-view style="display: none;"></router-view>
            <div
              v-if="guidedTourVisible"
              class="guided-tour-overlay"
              role="dialog"
              aria-modal="true"
              aria-label="Guided tour"
            >
              <div class="guided-tour-highlight" :style="guidedTourHighlightStyle" aria-hidden="true"></div>
              <div class="guided-tour-tooltip">
                <span class="guided-tour-step-label">
                  Step {{ guidedTourStepNumber }} of {{ guidedTourTotalSteps }}
                </span>
                <h3>{{ guidedTourCurrentStep ? guidedTourCurrentStep.title : '' }}</h3>
                <p>{{ guidedTourCurrentStep ? guidedTourCurrentStep.description : '' }}</p>
                <p v-if="guidedTourTargetMissing" class="guided-tour-missing">
                  Can't locate this panel? Make sure the dashboard is visible on a larger screen.
                </p>
                <div class="guided-tour-actions">
                  <button type="button" class="guided-tour-link" @click="closeGuidedTour">Skip</button>
                  <div class="guided-tour-actions__spacer"></div>
                  <button
                    type="button"
                    class="guided-tour-button"
                    :disabled="guidedTourStepNumber === 1"
                    @click="previousGuidedTourStep"
                  >
                    Back
                  </button>
                  <button
                    type="button"
                    class="guided-tour-button guided-tour-button--primary"
                    @click="advanceGuidedTour"
                  >
                    {{ isGuidedTourLastStep ? 'Finish tour' : 'Next' }}
                  </button>
                </div>
              </div>
            </div>
          </v-app>
        `,
      })
        .use(vuetify)
        .use(appRouter)
        .mount('#app');
    </script>
  </body>
</html>
