<!doctype html>
<html lang="en" data-theme="dark">
  <head>
    <meta charset="utf-8" />
    <title>Nightshift</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="icon"
      href="./nightshift-favicon-dark.png"
      type="image/png"
      sizes="256x256"
      data-nightshift-favicon="png"
    />
    <link
      rel="alternate icon"
      href="./nightshift-favicon-dark.ico"
      type="image/x-icon"
      data-nightshift-favicon="ico"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@7.4.47/css/materialdesignicons.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/vuetify@3.7.4/dist/vuetify.min.css" />
    <style>
      :root {
        --app-bg: #f3f4f6;
        --app-surface: #ffffff;
        --card-border: #d7dce3;
        --text-primary: #1f2933;
        --text-muted: #5d6675;
        --prompt-bubble-bg: #ffffff;
        --response-bubble-bg: #f8fafc;
        --response-text: #111827;
        --stream-bg: #f5f7fb;
        --stream-border: #c8ceda;
        --stderr-bg: #f1f5f9;
        --detail-summary-bg: #eceff5;
        --detail-panel-border: var(--stream-border);
        --detail-panel-open-bg: var(--app-surface);
        --divider-color: #d7dce3;
        --prompt-sticky-offset: 96px;
        --stdout-bg: var(--app-surface);
        --stdout-text: var(--text-primary);
      }

      :root[data-theme="dark"] {
        --app-bg: #0e1117;
        --app-surface: #161b22;
        --card-border: rgba(148, 163, 184, 0.35);
        --text-primary: #e5e7eb;
        --text-muted: #9ca3af;
        --prompt-bubble-bg: #232c3d;
        --response-bubble-bg: #162034;
        --response-text: #f8fafc;
        --stream-bg: rgba(31, 41, 55, 0.85);
        --stream-border: rgba(148, 163, 184, 0.3);
        --stderr-bg: rgba(148, 163, 184, 0.18);
        --detail-summary-bg: rgba(148, 163, 184, 0.35);
        --detail-panel-border: rgba(148, 163, 184, 0.45);
        --detail-panel-open-bg: rgba(255, 255, 255, 0.08);
        --divider-color: rgba(148, 163, 184, 0.35);
        --prompt-sticky-offset: 96px;
        --stdout-bg: #1e2430;
        --stdout-text: #f3f4f6;
      }

      @media (max-width: 640px) {
        :root,
        :root[data-theme="dark"] {
          --prompt-sticky-offset: 72px;
        }
      }

      html,
      body,
      #app {
        min-height: 100%;
        margin: 0;
        font-family: 'Roboto', sans-serif;
        background-color: var(--app-bg);
        color: var(--text-primary);
      }

      body {
        overflow-y: auto;
        overflow-x: hidden;
      }

      .v-application,
      .v-layout {
        min-height: 100%;
      }

      .v-main {
        background-color: var(--app-bg);
        min-height: calc(100vh - var(--v-layout-top, 64px));
        padding-top: var(--v-layout-top, 64px);
        box-sizing: border-box;
      }

      .main-layout {
        display: flex;
        flex-direction: column;
        box-sizing: border-box;
        min-height: calc(100vh - var(--v-layout-top, 64px));
      }

      @media (min-width: 960px) {
        .main-layout {
          height: calc(100vh - var(--v-layout-top, 64px));
        }
      }

      .main-row {
        flex: 1;
        min-height: 0;
        height: 100%;
        display: flex;
        flex-wrap: wrap;
        align-content: stretch;
        align-items: stretch;
        overflow: hidden;
      }

      .settings-row {
        flex: 1;
        min-height: 0;
        display: flex;
        flex-wrap: wrap;
        align-content: stretch;
        align-items: stretch;
      }

      .main-row > .v-col {
        display: flex;
        flex-direction: column;
        min-height: 0;
        height: 100%;
        box-sizing: border-box;
        max-width: 100%;
        overflow: hidden;
      }

      .settings-row > .v-col {
        display: flex;
        flex-direction: column;
        min-height: 0;
      }

      @media (min-width: 960px) {
        .main-row {
          flex-wrap: nowrap;
        }
        .main-row > .v-col {
          max-height: 100%;
        }
        .settings-row {
          flex-wrap: nowrap;
        }
      }

      .panel-card {
        border: 1px solid var(--card-border);
        border-radius: 16px;
        background-color: var(--app-surface);
        max-width: 100%;
      }

      .queue-card,
      .chat-card {
        display: flex;
        flex-direction: column;
        flex: 1 1 auto;
        max-height: 100%;
        min-height: 0;
        overflow: hidden;
      }

      .chat-card__header {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 0.75rem;
        flex-wrap: nowrap;
        min-height: 56px;
      }

      .chat-card__header-main {
        flex: 1 1 auto;
        min-width: 0;
      }

      .chat-card__header .thread-header__actions {
        flex: 0 0 auto;
      }

      .mobile-thread-nav,
      .mobile-panel-controls {
        display: none;
      }

      .mobile-thread-back {
        text-transform: none;
      }

      @media (max-width: 640px) {
        .chat-card__header {
          flex-direction: column;
          align-items: flex-start;
          gap: 0.5rem;
        }

        .chat-card__header .thread-header__actions {
          width: 100%;
          justify-content: flex-start;
        }
      }

      @media (max-width: 959px) {
        .mobile-panel-controls {
          display: flex;
          width: 100%;
          justify-content: flex-end;
          padding: 0.5rem 1.5rem 0;
        }

        .mobile-panel-controls .v-btn {
          text-transform: none;
        }

        .mobile-thread-nav {
          display: flex;
          width: 100%;
          margin-bottom: 0.25rem;
        }

        .mobile-thread-back {
          padding-left: 0;
        }
      }

      .log-card {
        display: flex;
        flex-direction: column;
        max-width: 100%;
      }

      .settings-log-card {
        height: 100%;
        display: flex;
        flex-direction: column;
        min-height: 0;
        overflow: hidden;
      }

      @media (min-width: 960px) {
        .settings-log-card {
          max-height: calc(100vh - var(--v-layout-top, 64px) - 96px);
        }
      }

      .settings-log-card .log-card__body {
        flex: 1 1 auto;
        display: flex;
        flex-direction: column;
        min-height: 0;
      }

      .settings-log-card .log-content {
        flex: 1 1 auto;
        min-height: 0;
        height: 100%;
        max-height: none;
      }

      .log-card__header {
        display: flex;
        justify-content: space-between;
        gap: 1rem;
        align-items: flex-start;
      }

      .log-card__actions {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .log-card__body {
        min-height: 220px;
      }

      .log-content {
        background-color: var(--stream-bg);
        border: 1px solid var(--stream-border);
        border-radius: 12px;
        padding: 0.75rem 1rem;
        font-family: 'Roboto Mono', 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        font-size: 0.85rem;
        line-height: 1.45;
        white-space: pre-wrap;
        word-break: break-word;
        max-height: 260px;
        overflow-y: auto;
      }

      .log-content pre {
        margin: 0;
      }

      .log-content--empty {
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--text-muted);
        font-style: italic;
      }

      .ssh-key-list {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .ssh-key-item {
        border: 1px solid var(--card-border);
        border-radius: 12px;
        padding: 0.75rem 1rem;
        background-color: var(--prompt-bubble-bg);
      }

      .ssh-key-header {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
      }

      .ssh-key-text {
        font-family: 'Roboto Mono', 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        font-size: 0.85rem;
        margin: 0;
        white-space: pre-wrap;
        word-break: break-word;
      }

      .log-content__placeholder {
        color: var(--text-muted);
      }

      .realtime-chip {
        text-transform: none;
        font-weight: 600;
      }

      .queue-scroll {
        flex: 1 1 auto;
        min-height: 0;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
        padding: 1.25rem 1.5rem;
      }

      .human-tasks-panel {
        padding: 1.25rem 1.5rem 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
      }

      .human-tasks-panel__header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .human-tasks-panel__header-title {
        font-weight: 600;
        font-size: 1rem;
      }

      .human-tasks-panel__badges {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        align-items: center;
      }

      .human-tasks-panel__body {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .human-tasks-list {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        max-height: 260px;
        overflow-y: auto;
      }

      .human-task-entry {
        border: 1px solid var(--card-border);
        border-radius: 12px;
        padding: 0.85rem 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        background-color: var(--app-surface);
      }

      .human-task-entry__header {
        display: flex;
        justify-content: space-between;
        gap: 0.5rem;
        align-items: center;
        font-weight: 600;
      }

      .human-task-entry__meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        font-size: 0.85rem;
        color: var(--text-muted);
      }

      .human-task-entry__description {
        margin: 0;
        font-size: 0.9rem;
        color: var(--text-primary);
      }

      .human-task-entry__footer {
        display: flex;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 0.5rem;
        font-size: 0.85rem;
        color: var(--text-muted);
      }

      .human-tasks-panel__empty {
        text-align: center;
        font-size: 0.9rem;
        color: var(--text-muted);
        padding: 0.75rem 0;
      }

      .human-tasks-panel__footer {
        font-size: 0.8rem;
        color: var(--text-muted);
      }

      .queue-list {
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
      }

      .queue-entry {
        border: 1px solid var(--card-border);
        border-radius: 12px;
        background-color: var(--app-surface);
        padding: 0.85rem 1rem;
        text-align: left;
        cursor: pointer;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        font: inherit;
      }

      .queue-entry:hover,
      .queue-entry:focus-visible {
        border-color: var(--text-muted);
        box-shadow: 0 4px 12px rgba(15, 23, 42, 0.08);
        outline: none;
      }

      .queue-entry.active {
        border-color: rgba(37, 99, 235, 0.65);
        box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.35);
      }

      .queue-entry-header {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem 1rem;
        align-items: center;
        font-family: 'Roboto Mono', 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        font-size: 0.85rem;
      }

      .queue-entry-index {
        font-weight: 600;
      }

      .queue-entry-status {
        text-transform: uppercase;
        letter-spacing: 0.08em;
        font-weight: 600;
      }

      .queue-entry-status.status-completed {
        color: #22c55e;
      }

      .queue-entry-status.status-failed {
        color: #f87171;
      }

      .queue-entry-status.status-running {
        color: #facc15;
      }

      .queue-entry-status.status-queued {
        color: #60a5fa;
      }

      .queue-entry-status.status-canceled {
        color: #f97316;
      }

      .queue-entry-detail {
        color: var(--text-muted);
        font-size: 0.9rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      @media (max-width: 959px) {
        .queue-card {
          max-height: min(75vh, 640px);
          flex: 0 0 auto;
        }

        .queue-entry-detail {
          white-space: normal;
          display: -webkit-box;
          -webkit-box-orient: vertical;
          -webkit-line-clamp: 2;
          line-clamp: 2;
          word-break: break-word;
        }
      }


      .chat-thread {
        flex: 1;
        min-height: 0;
        padding: 1.25rem 1.5rem;
        overflow-y: auto;
        max-height: 100%;
        display: flex;
        flex-direction: column;
        gap: 1.25rem;
        position: relative;
        scroll-padding-top: calc(var(--prompt-sticky-offset) + 1.5rem);
      }

      .attempt-entry {
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
      }

      .chat-message {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        max-width: 85%;
      }

      .chat-message.user {
        align-self: flex-end;
      }

      .chat-message.codex {
        align-self: flex-start;
      }

      .chat-bubble {
        border-radius: 16px;
        padding: 1.25rem;
        border: 1px solid var(--card-border);
        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.08);
        position: relative;
      }

      .chat-bubble.copyable {
        padding-right: 3.25rem;
      }

      .chat-bubble.prompt {
        background-color: var(--prompt-bubble-bg);
        color: var(--text-primary);
      }

      .chat-thread .chat-bubble.prompt {
        position: sticky;
        top: var(--prompt-sticky-offset);
        z-index: 5;
      }

      .chat-bubble.response {
        background-color: var(--response-bubble-bg);
        color: var(--response-text);
        max-height: none;
        overflow: visible;
      }

      .stdout-block,
      .stderr-block,
      .context-block {
        margin-top: 0.75rem;
        padding: 0.85rem;
        border-radius: 12px;
        background-color: var(--stream-bg);
        border: 1px solid var(--stream-border);
        white-space: pre-wrap;
        font-family: 'Roboto Mono', 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        font-size: 0.92rem;
        line-height: 1.5;
      }

      .stdout-block {
        color: var(--stdout-text);
        background-color: var(--stdout-bg);
        max-height: min(75vh, 520px);
        overflow-y: auto;
      }

      .stderr-block {
        background-color: var(--stderr-bg);
        color: inherit;
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
        max-height: min(50vh, 520px);
        overflow: scroll;
      }

      .stderr-segment {
        white-space: inherit;
        word-break: break-word;
      }

      .stderr-code-block,
      .stderr-exec-block {
        border: 1px dashed var(--stream-border);
        border-radius: 10px;
        padding: 0.35rem 0.65rem 0.65rem;
        background-color: rgba(15, 23, 42, 0.04);
      }

      :root[data-theme='dark'] .stderr-code-block,
      :root[data-theme='dark'] .stderr-exec-block {
        background-color: rgba(255, 255, 255, 0.04);
      }

      .stderr-code-block summary,
      .stderr-exec-block summary {
        cursor: pointer;
        list-style: none;
        font-size: 0.85rem;
        color: var(--text-muted);
        display: flex;
        align-items: center;
        gap: 0.4rem;
      }

      .stderr-code-block summary::-webkit-details-marker,
      .stderr-exec-block summary::-webkit-details-marker {
        display: none;
      }

      .stderr-code-summary {
        width: 100%;
        text-overflow: ellipsis;
        white-space: nowrap;
        overflow: hidden;
      }

      .stderr-code-summary__label {
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        font-size: 0.75rem;
      }

      .stderr-code-content {
        margin-top: 0.5rem;
        padding: 0.65rem;
        border-radius: 8px;
        background-color: rgba(15, 23, 42, 0.04);
        color: inherit;
        white-space: pre-wrap;
        overflow-x: auto;
      }

      :root[data-theme='dark'] .stderr-code-content {
        background-color: rgba(255, 255, 255, 0.04);
      }

      .context-block {
        color: var(--text-primary);
      }

      .detail-footer {
        border-top: 1px solid var(--divider-color);
        padding: 0.75rem 1.5rem 1.25rem;
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
        font-size: 0.85rem;
        color: var(--text-muted);
        flex-shrink: 0;
      }

      .queue-composer {
        padding: 1rem 1.5rem 1.25rem;
        background-color: var(--app-surface);
        flex-shrink: 0;
      }

      .average-prompt-time {
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
      }

      .average-prompt-time__value {
        font-weight: 600;
        color: var(--text-primary);
      }

      .composer-actions {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 0.75rem;
        gap: 1rem;
      }

      .detail-panel {
        margin-top: 0.8rem;
        border-radius: 12px;
        border: 1px solid var(--detail-panel-border);
        background-color: var(--detail-summary-bg);
        padding: 0.45rem 0.85rem;
      }

      .detail-panel summary {
        cursor: pointer;
        list-style: none;
        font-weight: 500;
        color: var(--text-muted);
        display: flex;
        align-items: center;
        gap: 0.4rem;
      }

      .detail-panel summary .copy-button {
        margin-left: auto;
      }

      .detail-panel summary::marker {
        display: none;
      }

      .detail-panel summary::-webkit-details-marker {
        display: none;
      }

      .detail-panel[open] {
        background-color: var(--detail-panel-open-bg);
      }

      .detail-panel .detail-content {
        margin-top: 0.75rem;
      }

      .message-meta {
        display: flex;
        gap: 0.85rem;
        flex-wrap: wrap;
        font-size: 0.8rem;
        color: var(--text-muted);
      }

      .message-meta--header {
        padding-inline: 0.25rem;
      }

      .chat-bubble .message-meta {
        margin-bottom: 0.75rem;
      }

      .prompt-text {
        white-space: pre-wrap;
        line-height: 1.6;
      }

      .copy-button {
        border: none;
        background: transparent;
        color: var(--text-muted);
        cursor: pointer;
        border-radius: 999px;
        padding: 0.15rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: color 0.2s ease, background-color 0.2s ease;
      }

      .copy-button:hover,
      .copy-button:focus-visible {
        color: var(--text-primary);
        background-color: rgba(148, 163, 184, 0.2);
        outline: none;
      }

      .copy-button .mdi {
        font-size: 1rem;
      }

      .copy-button--floating {
        position: absolute;
        top: 0.75rem;
        right: 0.75rem;
      }

      .prompt-bubble-actions {
        position: absolute;
        top: 0.65rem;
        right: 0.65rem;
        display: flex;
        flex-direction: column;
        gap: 0;
        align-items: flex-end;
      }

      .prompt-bubble-actions .copy-button {
        padding: 0.05rem 0.3rem;
        line-height: 1;
      }

      .prompt-edit-button .mdi {
        font-size: 1rem;
      }

      .thread-header__actions {
        margin-left: auto;
        display: flex;
        flex-wrap: wrap;
        justify-content: flex-end;
        align-items: center;
        gap: 0.5rem;
      }

      .stdout-empty {
        opacity: 0.7;
        font-style: italic;
      }

      .global-header {
        background-color: var(--app-surface);
        border-bottom: 1px solid var(--card-border);
        padding-inline-end: 1.25rem;
      }

      .global-header__branding {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .global-header__home-link {
        font: inherit;
        color: inherit;
        background: transparent;
        border: none;
        padding: 0;
        margin: 0;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 0.6rem;
        text-decoration: none;
      }

      .global-header__home-link:focus-visible {
        outline: 2px solid var(--card-border);
        outline-offset: 2px;
        border-radius: 6px;
      }

      .global-header__logo {
        width: 36px;
        height: 36px;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        flex-shrink: 0;
      }

      .global-header__title {
        font-size: 1.35rem;
        font-weight: 600;
        letter-spacing: 0.01em;
      }

      .theme-toggle {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: space-between;
        width: 88px;
        height: 36px;
        padding: 0 14px;
        border-radius: 999px;
        border: none;
        background-color: var(--app-surface);
        box-shadow: inset 0 0 0 1px var(--card-border);
        cursor: pointer;
        transition: background-color 0.2s ease, border-color 0.2s ease;
        gap: 10px;
        appearance: none;
        font: inherit;
        color: inherit;
      }

      .theme-toggle:focus-visible {
        outline: 2px solid var(--card-border);
        outline-offset: 2px;
      }

      .theme-toggle__icon {
        font-size: 16px;
        color: var(--text-muted);
        pointer-events: none;
      }

      .theme-toggle__thumb {
        position: absolute;
        top: 3px;
        left: 4px;
        width: 38px;
        height: 30px;
        border-radius: 999px;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: var(--app-bg);
        box-shadow: 0 4px 12px rgba(15, 23, 42, 0.25);
        transition: transform 0.25s ease, background-color 0.2s ease;
      }

      .theme-toggle__thumb--right {
        transform: translateX(36px);
      }

      .theme-toggle__thumb .mdi {
        font-size: 18px;
        color: var(--text-primary);
      }

      .header-theme-toggle {
        margin-right: 1rem;
      }

      .queue-card-title {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        min-height: 56px;
      }

      .queue-card-title span:first-child {
        font-size: 1rem;
        font-weight: 500;
      }

      .header-menus {
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }

      .user-menu__activator {
        text-transform: none;
        display: flex;
        align-items: center;
        gap: 0.35rem;
        color: var(--text-primary) !important;
        font-weight: 600;
      }

      .user-menu__activator .mdi {
        font-size: 18px;
      }

      .project-selector {
        padding: 1rem 1.5rem 0.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .project-selector__hint {
        font-size: 0.85rem;
        color: var(--text-muted);
      }

      .project-selector__live-link {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        font-weight: 500;
        color: var(--text-primary);
        text-decoration: none;
      }

      .project-selector__live-link .mdi {
        font-size: 1rem;
        opacity: 0.8;
      }

      .project-selector__live-link:focus-visible {
        outline: 2px solid rgba(96, 165, 250, 0.5);
        outline-offset: 2px;
      }

      .project-selector__live-link--disabled {
        color: var(--text-muted);
        cursor: default;
      }

      .prompt-project-pill {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        padding: 0.1rem 0.5rem;
        border-radius: 999px;
        border: 1px solid rgba(59, 130, 246, 0.4);
        font-size: 0.55rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: #60a5fa;
      }

      .chat-card-title__heading {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.35rem;
        font-size: 1rem;
        font-weight: 500;
        width: 100%;
      }

      .chat-card-title__task {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        flex-wrap: wrap;
      }

      .chat-card-title__cancel,
      .chat-card-title__delete {
        flex-shrink: 0;
      }

      .chat-card-subtitle {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .chat-card-subtitle__attempts {
        margin-right: auto;
      }

      .task-id-button {
        border: none;
        background: none;
        color: inherit;
        font: inherit;
        padding: 0;
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        cursor: pointer;
      }

      .task-id-button .mdi {
        font-size: 0.95rem;
      }

      .task-id-button:focus-visible {
        outline: 2px solid #60a5fa;
        outline-offset: 2px;
        border-radius: 6px;
      }

      .login-container {
        min-height: calc(100vh - var(--v-layout-top, 64px));
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem 1rem;
      }

      .login-wrapper {
        width: 100%;
        max-width: 420px;
      }

      .login-card {
        padding-bottom: 1rem;
      }

      .user-summary {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        font-size: 0.9rem;
        color: var(--text-muted);
      }

      .user-summary__email {
        font-weight: 600;
      }

      .user-menu-card {
        min-width: 250px;
        padding: 0.25rem 0;
      }

      .user-menu-icon {
        margin-right: 0.4rem;
        font-size: 18px;
      }

      .logout-theme-toggle {
        margin-left: 0.75rem;
      }

      .logout-list-item {
        text-transform: none;
      }

      .guided-tour-trigger {
        text-transform: none;
        font-weight: 600;
        font-size: 0.6rem;
        padding: 0.02rem 0.35rem;
        min-height: 20px;
        border-radius: 999px;
        align-self: center;
        letter-spacing: 0.02em;
      }

      .guided-tour-trigger .v-btn__prepend {
        margin-right: 0.25rem;
      }

      .guided-tour-trigger .v-btn__prepend .v-icon {
        font-size: 0.85rem;
      }

      .guided-tour-overlay {
        position: fixed;
        inset: 0;
        z-index: 4000;
        pointer-events: none;
      }

      .guided-tour-highlight {
        position: fixed;
        border-radius: 18px;
        border: 2px solid rgba(96, 165, 250, 0.95);
        box-shadow:
          0 20px 60px rgba(15, 23, 42, 0.35),
          0 0 0 9999px rgba(8, 15, 33, 0.75);
        transition: all 0.2s ease;
        pointer-events: none;
      }

      .guided-tour-tooltip {
        position: fixed;
        left: 50%;
        bottom: 32px;
        transform: translateX(-50%);
        max-width: min(520px, calc(100vw - 32px));
        background: var(--app-surface);
        color: var(--text-primary);
        border-radius: 16px;
        border: 1px solid var(--card-border);
        padding: 1.25rem 1.5rem;
        box-shadow: 0 20px 45px rgba(15, 23, 42, 0.3);
        pointer-events: auto;
      }

      .guided-tour-step-label {
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--text-muted);
        margin-bottom: 0.35rem;
        display: block;
      }

      .guided-tour-tooltip h3 {
        margin: 0;
        font-size: 1.1rem;
      }

      .guided-tour-tooltip p {
        margin: 0.35rem 0 0;
        line-height: 1.5;
      }

      .guided-tour-missing {
        font-size: 0.9rem;
        color: #fbbf24;
      }

      .guided-tour-actions {
        margin-top: 1rem;
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }

      .guided-tour-actions__spacer {
        flex: 1;
      }

      .guided-tour-link {
        background: transparent;
        border: none;
        padding: 0;
        font: inherit;
        color: #93c5fd;
        cursor: pointer;
        text-decoration: underline;
      }

      .guided-tour-link:focus-visible {
        outline: 2px solid rgba(96, 165, 250, 0.5);
        outline-offset: 2px;
      }

      .guided-tour-button {
        border-radius: 999px;
        border: 1px solid var(--card-border);
        background: transparent;
        color: var(--text-primary);
        font: inherit;
        padding: 0.35rem 1.25rem;
        cursor: pointer;
        transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
      }

      .guided-tour-button:focus-visible {
        outline: 2px solid rgba(96, 165, 250, 0.5);
        outline-offset: 2px;
      }

      .guided-tour-button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .guided-tour-button--primary {
        background-color: #2563eb;
        border-color: #2563eb;
        color: #ffffff;
      }

    </style>
  </head>
  <body>
    <div id="app"></div>

    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://unpkg.com/vue-router@4/dist/vue-router.global.prod.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuetify@3.7.4/dist/vuetify.min.js"></script>
    <script>
      const { createApp, ref, reactive, computed, onMounted, onUnmounted, watch, nextTick } = Vue;
      const { createVuetify, useTheme } = Vuetify;
      const { createRouter, createWebHashHistory, useRoute, useRouter } = VueRouter;
      const THEME_STORAGE_KEY = 'codex-theme-mode';
      const AUTH_TOKEN_KEY = 'codex-auth-token';
      const PROJECT_STORAGE_KEY = 'codex-active-project';
      const QUEUE_DETAIL_MAX = 160;
      const QUEUE_DETAIL_MOBILE_MAX = 96;
      const WS_RECONNECT_MIN_MS = 1000;
      const WS_RECONNECT_MAX_MS = 10000;
      const LOG_REFRESH_INTERVAL_MS = 30000;
      const PROMPT_AVERAGE_WINDOW = 20;
      const PROMPT_DURATION_STATUSES = new Set(['completed', 'failed', 'canceled']);
      const MOBILE_BREAKPOINT = 960;
      const GUIDED_TOUR_PADDING = 16;
      const GUIDED_TOUR_STEPS = [
        {
          id: 'project-focus',
          target: '[data-tour-id=\"tour-project-selector\"]',
          title: 'Focus Codex on the right project',
          description: 'Pick which project Codex should care about. This choice scopes prompts, context, and launch links.',
        },
        {
          id: 'prompt-composer',
          target: '[data-tour-id=\"tour-prompt-composer\"]',
          title: 'Compose a new instruction',
          description: 'Type what you want Codex to do, then press Send. Average turn duration helps you know how long you might wait.',
        },
        {
          id: 'prompt-queue',
          target: '[data-tour-id=\"tour-queue-list\"]',
          title: 'Track the Task queue',
          description: 'Each entry shows status, timing, and a quick summary so you can jump into any task while it runs.',
        },
        {
          id: 'human-task-queue',
          target: '[data-tour-id=\"tour-human-tasks\"]',
          title: 'Spot blockers fast',
          description: 'Human Tasks capture anything that needs an operator. Add blockers via the CLI and monitor them here.',
        },
        {
          id: 'prompt-thread',
          target: '[data-tour-id=\"tour-thread-panel\"]',
          title: 'Review Codex output',
          description: 'The thread view holds your prompt, live stdout/stderr, and prior attemptsâ€”plus controls to edit, cancel, or retry.',
        },
      ];
      const HUMAN_TASK_STATUS_LABELS = {
        open: 'Open',
        in_progress: 'In progress',
        resolved: 'Resolved',
      };
      const HUMAN_TASK_STATUS_ORDER = {
        open: 0,
        in_progress: 1,
        resolved: 2,
      };

      const HEADER_ICON_SOURCES = {
        dark: './nightshift-header-dark.png',
        light: './nightshift-header-light.png',
      };
      const FAVICON_SOURCES = {
        dark: {
          png: {
            href: './nightshift-favicon-dark.png',
            type: 'image/png',
            sizes: '256x256',
          },
          ico: {
            href: './nightshift-favicon-dark.ico',
            type: 'image/x-icon',
          },
        },
        light: {
          png: {
            href: './nightshift-favicon-light.png',
            type: 'image/png',
            sizes: '256x256',
          },
          ico: {
            href: './nightshift-favicon-light.ico',
            type: 'image/x-icon',
          },
        },
      };

      const createApiClient = (getToken, onUnauthorized) => {
        return async (path, options = {}) => {
          const headers = { 'Content-Type': 'application/json', ...(options.headers || {}) };
          const token = typeof getToken === 'function' ? getToken() : null;
          if (token) {
            headers.Authorization = `Bearer ${token}`;
          }
          const response = await fetch(path, {
            ...options,
            headers,
          });
          if (response.status === 401 && typeof onUnauthorized === 'function') {
            onUnauthorized();
          }
          if (!response.ok) {
            const err = await response.json().catch(() => ({ error: response.statusText }));
            throw new Error(err.error || 'Request failed');
          }
          return response.json();
        };
      };

      const vuetify = createVuetify({
        theme: {
          defaultTheme: 'dark',
          themes: {
            dark: {
              dark: true,
              colors: {
                background: '#0e1117',
                surface: '#161b22',
                primary: '#2563eb',
                secondary: '#7c3aed',
                success: '#10b981',
                warning: '#f97316',
                error: '#ef4444',
                info: '#38bdf8',
              },
            },
            light: {
              dark: false,
              colors: {
                background: '#f3f4f6',
                surface: '#ffffff',
                primary: '#1d4ed8',
                secondary: '#7c3aed',
                success: '#16a34a',
                warning: '#fb923c',
                error: '#dc2626',
                info: '#0ea5e9',
              },
            },
          },
        },
      });

      const appRouter = createRouter({
        history: createWebHashHistory(),
        routes: [
          {
            path: '/settings',
            name: 'settings',
            component: { template: '<div />' },
          },
          {
            path: '/:promptId?',
            name: 'queue',
            component: { template: '<div />' },
          },
        ],
      });

      createApp({
        setup() {
          const promptText = ref('');
          const queue = ref([]);
          const selectedPrompt = ref(null);
          const nowTick = ref(Date.now());
          const loading = ref(true);
          const submitting = ref(false);
          const headerIconRequesting = ref(false);
          const health = ref(null);
          const operationsLog = ref('');
          const logLoading = ref(false);
          const logError = ref('');
          const logLastUpdated = ref('');
          const humanTasks = ref([]);
          const humanTasksSummary = ref({});
          const humanTasksError = ref('');
          const humanTasksLoading = ref(false);
          const humanTasksRevision = ref(null);
          const retrying = ref(false);
          const canceling = ref(false);
          const restarting = ref(false);
          const promptStreams = reactive({});
          const editPromptDialogVisible = ref(false);
          const editPromptText = ref('');
          const editPromptError = ref('');
          const editPromptSaving = ref(false);
          const projectOptions = ref([]);
          const selectedProjectId = ref('');
          const defaultProjectId = ref(null);
          const websocketRef = ref(null);
          const wsStatus = ref('disconnected');
          const realtimeReady = ref(false);
          const reconnectAttempts = ref(0);
          const theme = useTheme();
          const themeMode = ref('dark');
          const headerIconSrc = computed(() => HEADER_ICON_SOURCES[themeMode.value] || HEADER_ICON_SOURCES.dark);
          const route = useRoute();
          const router = useRouter();
          const dateFormatter = new Intl.DateTimeFormat(undefined, { dateStyle: 'long' });
          const timeFormatter = new Intl.DateTimeFormat(undefined, { timeStyle: 'short' });
          const timestampFormatter = new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'short' });
          const queueTimestampFormatter = new Intl.DateTimeFormat(undefined, {
            month: 'short',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
          });
          const chatThreadRef = ref(null);
          const chatThreadHeight = ref(0);
          const liveStreamScrollRef = ref(null);
          let chatThreadResizeObserver = null;
          let reconnectTimer = null;
          let logRefreshTimer = null;
          let elapsedTimer = null;
          let manualRealtimeClose = false;
          const authToken = ref('');
          const currentUser = ref(null);
          const loginEmail = ref('ulfurk@ulfurk.com');
          const loginPassword = ref('');
          const showPassword = ref(false);
          const loginError = ref('');
          const loginLoading = ref(false);
          const activeView = ref('queue');
          const passwordForm = reactive({
            current: '',
            newValue: '',
            confirm: '',
          });
          const passwordChangeLoading = ref(false);
          const passwordChangeError = ref('');
          const passwordChangeSuccess = ref('');
          const sshKeys = ref([]);
          const sshKeysLoading = ref(false);
          const sshKeysError = ref('');
          const sshKeysLastFetched = ref('');
          const lastQueuePromptId = ref('');
          const viewportWidth = ref(typeof window !== 'undefined' ? window.innerWidth : MOBILE_BREAKPOINT);
          const activeMobilePanel = ref('queue');
          const isMobileLayout = computed(() => viewportWidth.value < MOBILE_BREAKPOINT);
          const isAuthenticated = computed(() => Boolean(authToken.value));
          const guidedTourActive = ref(false);
          const guidedTourStepIndex = ref(0);
          const guidedTourHighlightRect = ref(null);
          const guidedTourTargetMissing = ref(false);
          const guidedTourCurrentStep = computed(() => GUIDED_TOUR_STEPS[guidedTourStepIndex.value] || null);
          const guidedTourVisible = computed(() => guidedTourActive.value && Boolean(guidedTourCurrentStep.value));
          const guidedTourStepNumber = computed(() => guidedTourStepIndex.value + 1);
          const guidedTourTotalSteps = GUIDED_TOUR_STEPS.length;
          const isGuidedTourLastStep = computed(() => guidedTourStepNumber.value >= guidedTourTotalSteps);
          const canStartGuidedTour = computed(
            () =>
              isAuthenticated.value &&
              activeView.value === 'queue' &&
              !isMobileLayout.value &&
              GUIDED_TOUR_STEPS.length > 0
          );
          const guidedTourHighlightStyle = computed(() => {
            if (!guidedTourVisible.value || !guidedTourHighlightRect.value) {
              return { display: 'none' };
            }
            const rect = guidedTourHighlightRect.value;
            const padding = GUIDED_TOUR_PADDING;
            const top = Math.max(0, rect.top - padding);
            const left = Math.max(0, rect.left - padding);
            return {
              top: `${top}px`,
              left: `${left}px`,
              width: `${rect.width + padding * 2}px`,
              height: `${rect.height + padding * 2}px`,
            };
          });
          const resetPasswordForm = () => {
            passwordForm.current = '';
            passwordForm.newValue = '';
            passwordForm.confirm = '';
          };
          const resetSettingsState = () => {
            passwordChangeError.value = '';
            passwordChangeSuccess.value = '';
            passwordChangeLoading.value = false;
            sshKeys.value = [];
            sshKeysError.value = '';
            sshKeysLoading.value = false;
            sshKeysLastFetched.value = '';
            resetPasswordForm();
          };
          const openSettingsView = () => {
            router.push({ name: 'settings' }).catch(() => {});
          };
          const returnToQueueView = () => {
            resetSettingsState();
            if (lastQueuePromptId.value) {
              router.push({ name: 'queue', params: { promptId: lastQueuePromptId.value } }).catch(() => {});
            } else {
              router.push({ name: 'queue' }).catch(() => {});
            }
          };
          const canSubmitPassword = computed(() => {
            if (!passwordForm.current || !passwordForm.newValue || !passwordForm.confirm) {
              return false;
            }
            if (passwordForm.newValue !== passwordForm.confirm) {
              return false;
            }
            if (passwordForm.newValue === passwordForm.current) {
              return false;
            }
            return passwordForm.newValue.length >= 8;
          });

          const clearRoutePrompt = () => {
            const currentPrompt = normalizePromptId(route.params.promptId);
            if (currentPrompt || route.name !== 'queue') {
              router.replace({ name: 'queue' }).catch(() => {});
            }
          };

          const goHome = () => {
            resetSettingsState();
            router.push({ name: 'queue' }).catch(() => {});
          };

          const handleHeaderIconClick = (event) => {
            if (event?.preventDefault) {
              event.preventDefault();
            }
            if (isAuthenticated.value) {
              queueHeaderIconRefreshTask();
            }
            goHome();
          };

          const showQueuePanel = () => {
            if (isMobileLayout.value) {
              activeMobilePanel.value = 'queue';
            }
          };

          const showThreadPanel = () => {
            if (isMobileLayout.value) {
              activeMobilePanel.value = 'thread';
            }
          };

          watch(
            () => route.name,
            (name, previous) => {
              const nextView = name === 'settings' ? 'settings' : 'queue';
              if (activeView.value !== nextView) {
                activeView.value = nextView;
              }
              if (previous === 'settings' && nextView === 'queue') {
                resetSettingsState();
              }
            },
            { immediate: true }
          );

          watch(
            () => [route.name, route.params.promptId],
            ([name, promptId]) => {
              if (name === 'queue') {
                lastQueuePromptId.value = normalizePromptId(promptId);
              }
            },
            { immediate: true }
          );

          watch(
            selectedProjectId,
            (value) => {
              if (!value || !projectLookup.value.has(value)) {
                persistProjectSelection('');
                return;
              }
              persistProjectSelection(value);
            }
          );

          watch(isMobileLayout, (isMobile) => {
            if (!isMobile) {
              activeMobilePanel.value = 'queue';
              refreshGuidedTourHighlight();
              return;
            }
            if (guidedTourActive.value) {
              closeGuidedTour();
            }
            if (!selectedPrompt.value) {
              activeMobilePanel.value = 'queue';
            }
          });

          watch(selectedPrompt, (prompt) => {
            if (!prompt && isMobileLayout.value) {
              activeMobilePanel.value = 'queue';
            }
            refreshGuidedTourHighlight();
          });

          watch(guidedTourStepIndex, () => {
            refreshGuidedTourHighlight();
          });

          watch(
            () => guidedTourActive.value,
            (active) => {
              if (active) {
                refreshGuidedTourHighlight();
              } else {
                guidedTourHighlightRect.value = null;
                guidedTourTargetMissing.value = false;
              }
            }
          );

          watch(activeView, (view) => {
            if (view !== 'queue' && guidedTourActive.value) {
              closeGuidedTour();
            } else {
              refreshGuidedTourHighlight();
            }
          });

          watch(
            () => isAuthenticated.value,
            (authed) => {
              if (!authed && guidedTourActive.value) {
                closeGuidedTour();
              }
            }
          );

          const persistToken = (token) => {
            if (typeof window === 'undefined' || !window.localStorage) {
              return;
            }
            try {
              if (token) {
                window.localStorage.setItem(AUTH_TOKEN_KEY, token);
              } else {
                window.localStorage.removeItem(AUTH_TOKEN_KEY);
              }
            } catch (error) {
              console.warn('Unable to persist auth token', error);
            }
          };

          const loadStoredProjectId = () => {
            if (typeof window === 'undefined' || !window.localStorage) {
              return '';
            }
            try {
              return window.localStorage.getItem(PROJECT_STORAGE_KEY) || '';
            } catch (error) {
              console.warn('Unable to read stored project focus', error);
              return '';
            }
          };

          const persistProjectSelection = (projectId) => {
            if (typeof window === 'undefined' || !window.localStorage) {
              return;
            }
            try {
              if (projectId) {
                window.localStorage.setItem(PROJECT_STORAGE_KEY, projectId);
              } else {
                window.localStorage.removeItem(PROJECT_STORAGE_KEY);
              }
            } catch (error) {
              console.warn('Unable to persist project focus', error);
            }
          };

          const applyProjectSelection = () => {
            const availableIds = projectOptions.value
              .map((project) => project?.id)
              .filter((id) => typeof id === 'string' && id.length);
            if (!availableIds.length) {
              selectedProjectId.value = '';
              return;
            }
            const stored = loadStoredProjectId();
            const candidates = [
              stored,
              selectedProjectId.value,
              defaultProjectId.value,
              availableIds[0],
            ];
            const resolved = candidates.find((id) => id && availableIds.includes(id));
            selectedProjectId.value = resolved || '';
          };

          const resetSessionState = () => {
            queue.value = [];
            selectedPrompt.value = null;
            health.value = null;
            promptText.value = '';
            operationsLog.value = '';
            logLastUpdated.value = '';
            logError.value = '';
            logLoading.value = false;
            Object.keys(promptStreams).forEach((key) => delete promptStreams[key]);
          };

          const buildWebSocketUrl = () => {
            if (typeof window === 'undefined') {
              return '';
            }
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            return `${protocol}//${window.location.host}/ws`;
          };

          const clearReconnectTimer = () => {
            if (reconnectTimer) {
              clearTimeout(reconnectTimer);
              reconnectTimer = null;
            }
          };

          const clearLogRefreshTimer = () => {
            if (logRefreshTimer) {
              clearInterval(logRefreshTimer);
              logRefreshTimer = null;
            }
          };

          const stopLogRefresh = () => {
            clearLogRefreshTimer();
          };

          const disconnectRealtime = ({ manual = false } = {}) => {
            if (manual) {
              manualRealtimeClose = true;
            }
            clearReconnectTimer();
            realtimeReady.value = false;
            wsStatus.value = 'disconnected';
            const socket = websocketRef.value;
            if (socket) {
              websocketRef.value = null;
              try {
                socket.close();
              } catch (error) {
                console.warn('Unable to close realtime socket', error);
              }
            }
          };

          const scheduleReconnect = () => {
            if (!isAuthenticated.value || manualRealtimeClose) {
              return;
            }
            clearReconnectTimer();
            const attempt = reconnectAttempts.value + 1;
            reconnectAttempts.value = attempt;
            const delay = Math.min(WS_RECONNECT_MIN_MS * 2 ** (attempt - 1), WS_RECONNECT_MAX_MS);
            reconnectTimer = setTimeout(() => {
              connectRealtime();
            }, delay);
          };

          const sendRealtimeMessage = (message) => {
            if (!websocketRef.value || websocketRef.value.readyState !== WebSocket.OPEN) {
              return false;
            }
            try {
              websocketRef.value.send(JSON.stringify(message));
              return true;
            } catch (error) {
              console.error('Unable to send realtime payload', error);
              return false;
            }
          };

          const handleRealtimeMessage = (event) => {
            let packet;
            try {
              packet = JSON.parse(event.data);
            } catch (error) {
              console.warn('Unable to parse realtime payload', error);
              return;
            }
            const { type, payload } = packet || {};
            switch (type) {
              case 'auth_ok':
                realtimeReady.value = true;
                if (payload?.user) {
                  currentUser.value = payload.user;
                }
                loading.value = false;
                sendRealtimeMessage({ type: 'request_queue' });
                if (selectedPrompt.value?.prompt_id) {
                  sendRealtimeMessage({ type: 'fetch_prompt', prompt_id: selectedPrompt.value.prompt_id });
                }
                break;
              case 'queue_snapshot':
                updateQueue(payload?.items || []);
                loading.value = false;
                break;
              case 'prompt_update':
                if (payload?.prompt) {
                  mergeQueueEntry(payload.prompt);
                  if (selectedPrompt.value?.prompt_id === payload.prompt.prompt_id) {
                    selectedPrompt.value = payload.prompt;
                  }
                  const status = (payload.prompt.status || '').toLowerCase();
                  if (status === 'completed' || status === 'failed') {
                    clearStreamState(payload.prompt.prompt_id);
                  }
                }
                break;
              case 'prompt_deleted': {
                const deletedId = payload?.prompt_id;
                if (deletedId) {
                  const index = queue.value.findIndex((item) => item.prompt_id === deletedId);
                  if (index !== -1) {
                    queue.value.splice(index, 1);
                  }
                  if (selectedPrompt.value?.prompt_id === deletedId) {
                    selectedPrompt.value = null;
                    router.replace({ name: 'queue' }).catch(() => {});
                  }
                  clearStreamState(deletedId);
                }
                break;
              }
              case 'health':
                health.value = payload;
                applyHumanTaskMetrics(payload?.metrics?.human_tasks);
                break;
              case 'prompt_stream':
                handleStreamPayload(payload);
                break;
              case 'hello':
              case 'pong':
                break;
              case 'error':
                console.error('Realtime error', payload?.message || payload);
                break;
              default:
                console.debug('Unhandled realtime packet', packet);
            }
          };

          const handleStreamPayload = (payload) => {
            const promptId = payload?.prompt_id;
            if (!promptId) {
              return;
            }
            const streamName = (payload?.stream || '').toLowerCase();
            if (streamName !== 'stdout' && streamName !== 'stderr') {
              return;
            }
            const state = getStreamState(promptId);
            if (!state) {
              return;
            }
            const timestamp = payload.timestamp || new Date().toISOString();
            if (payload.reset) {
              state.stdout = '';
              state.stderr = '';
              state.done = false;
              state.started_at = timestamp;
            }
            if (!state.started_at) {
              state.started_at = timestamp;
            }
            if (typeof payload.chunk === 'string' && payload.chunk.length) {
              state[streamName] = (state[streamName] || '') + payload.chunk;
            }
            if (payload.done) {
              state.done = true;
            }
            state.updated_at = timestamp;
            if (selectedPrompt.value?.prompt_id === promptId) {
              selectedPrompt.value = {
                ...selectedPrompt.value,
                live_stream: { ...state },
              };
            }
          };

          const connectRealtime = () => {
            if (!isAuthenticated.value || wsStatus.value === 'connecting' || wsStatus.value === 'open') {
              return;
            }
            manualRealtimeClose = false;
            clearReconnectTimer();
            const url = buildWebSocketUrl();
            if (!url) {
              return;
            }
            wsStatus.value = 'connecting';
            try {
              const socket = new WebSocket(url);
              websocketRef.value = socket;

              socket.addEventListener('open', () => {
                wsStatus.value = 'open';
                reconnectAttempts.value = 0;
                sendRealtimeMessage({ type: 'auth', token: authToken.value });
              });
              socket.addEventListener('message', handleRealtimeMessage);
              socket.addEventListener('close', () => {
                websocketRef.value = null;
                realtimeReady.value = false;
                wsStatus.value = 'closed';
                if (!manualRealtimeClose) {
                  scheduleReconnect();
                }
              });
              socket.addEventListener('error', (error) => {
                console.error('Realtime socket error', error);
                socket.close();
              });
            } catch (error) {
              console.error('Unable to open realtime socket', error);
              scheduleReconnect();
            }
          };

          const handleUnauthorized = (message) => {
            disconnectRealtime({ manual: true });
            stopLogRefresh();
            resetSessionState();
            resetSettingsState();
            activeView.value = 'queue';
            authToken.value = '';
            currentUser.value = null;
            loading.value = false;
            submitting.value = false;
            retrying.value = false;
            canceling.value = false;
            restarting.value = false;
            persistToken('');
            clearRoutePrompt();
            humanTasks.value = [];
            humanTasksSummary.value = {};
            humanTasksRevision.value = null;
            humanTasksError.value = '';
            humanTasksLoading.value = false;
            if (message) {
              loginError.value = message;
            }
          };

          const api = createApiClient(
            () => authToken.value,
            () => handleUnauthorized('Session expired. Please sign in again.')
          );

          const formatDate = (isoString) => {
            if (!isoString) return 'â€”';
            try {
              const date = new Date(isoString);
              return `${dateFormatter.format(date)} at ${timeFormatter.format(date)}`;
            } catch (error) {
              console.error('Unable to format date', error);
              return isoString;
            }
          };

          const formatTimestamp = (isoString) => {
            if (!isoString) return 'â€”';
            try {
              return timestampFormatter.format(new Date(isoString));
            } catch (error) {
              console.error('Unable to format timestamp', error);
              return isoString;
            }
          };

          const formatDuration = (seconds) => {
            if (seconds == null || Number.isNaN(seconds)) {
              return 'â€”';
            }
            if (seconds < 1) {
              return `${Math.round(seconds * 1000)} ms`;
            }
            if (seconds < 10) {
              return `${seconds.toFixed(1)} s`;
            }
            return `${Math.round(seconds)} s`;
          };

          const formatQueueDuration = (seconds) => {
            if (seconds == null || Number.isNaN(seconds)) {
              return 'â€”';
            }
            const totalSeconds = Math.max(0, Math.round(seconds));
            const minutes = Math.floor(totalSeconds / 60);
            const remainingSeconds = totalSeconds % 60;
            return `${minutes}m ${remainingSeconds.toString().padStart(2, '0')}s`;
          };

          const formatHumanTaskStatus = (status) => {
            if (!status) {
              return 'Unknown';
            }
            const normalized = String(status).toLowerCase();
            return HUMAN_TASK_STATUS_LABELS[normalized] || status;
          };

          const normalizeWhitespace = (value) => {
            if (!value) return '';
            return value.replace(/\s+/g, ' ').trim();
          };

          const CODE_FENCE_REGEX = /```([\s\S]*?)```/g;
          const CODE_PREVIEW_MAX_CHARS = 96;

          const buildCodeBlockPreview = (content) => {
            if (!content) {
              return 'Code block';
            }
            const normalized = content.replace(/\s+/g, ' ').trim();
            if (!normalized) {
              return 'Code block';
            }
            if (normalized.length > CODE_PREVIEW_MAX_CHARS) {
              return `${normalized.slice(0, CODE_PREVIEW_MAX_CHARS - 1)}â€¦`;
            }
            return normalized;
          };

          const collapseThinkingSections = (content) => {
            if (!content || !content.includes('thinking')) {
              return content;
            }
            const lines = content.split('\n');
            if (lines.length < 3) {
              return content;
            }
            const collapsedLines = [];
            for (let i = 0; i < lines.length; i++) {
              const trimmed = lines[i].trim();
              if (trimmed !== 'thinking') {
                collapsedLines.push(lines[i]);
                continue;
              }
              const titleLine = lines[i + 1];
              if (!titleLine) {
                collapsedLines.push(lines[i]);
                continue;
              }
              const titleMatch = titleLine.trim().match(/^\*\*(.+?)\*\*$/);
              if (!titleMatch) {
                collapsedLines.push(lines[i]);
                continue;
              }
              const titleText = titleMatch[1].trim() || titleMatch[1];
              let nextIndex = i + 2;
              while (nextIndex < lines.length && !lines[nextIndex].trim()) {
                nextIndex += 1;
              }
              if (nextIndex < lines.length) {
                const candidate = lines[nextIndex].trim();
                if (candidate && candidate.toLowerCase() !== 'thinking' && !candidate.startsWith('**')) {
                  nextIndex += 1;
                }
              }
              collapsedLines.push(titleText);
              i = nextIndex - 1;
            }
            return collapsedLines.join('\n');
          };

          const parseCodeAndTextSegments = (chunk) => {
            const rawContent = chunk == null ? '' : String(chunk);
            if (!rawContent) {
              return [];
            }
            const content = collapseThinkingSections(rawContent);
            const segments = [];
            let lastIndex = 0;
            CODE_FENCE_REGEX.lastIndex = 0;
            let match;
            while ((match = CODE_FENCE_REGEX.exec(content)) !== null) {
              if (match.index > lastIndex) {
                segments.push({
                  type: 'text',
                  content: content.slice(lastIndex, match.index),
                });
              }
              const rawBlock = match[1] || '';
              let language = '';
              let codeContent = rawBlock;
              const newlineIndex = rawBlock.indexOf('\n');
              if (newlineIndex !== -1) {
                const firstLine = rawBlock.slice(0, newlineIndex).trim();
                const remainder = rawBlock.slice(newlineIndex + 1);
                if (firstLine && remainder) {
                  language = firstLine;
                  codeContent = remainder;
                } else if (!firstLine) {
                  codeContent = remainder;
                }
              }
              segments.push({
                type: 'code',
                language,
                content: codeContent,
                preview: buildCodeBlockPreview(codeContent || rawBlock),
              });
              lastIndex = match.index + match[0].length;
            }
            if (lastIndex < content.length) {
              segments.push({
                type: 'text',
                content: content.slice(lastIndex),
              });
            }
            return segments;
          };

          const findCollapseRanges = (text) => {
            if (!text) {
              return [];
            }
            const normalizedText = text.toLowerCase();
            if (!normalizedText.includes('exec') && !normalizedText.includes('file update')) {
              return [];
            }
            const lines = text.split('\n');
            const linePositions = [];
            let cursor = 0;
            for (let i = 0; i < lines.length; i++) {
              const lineText = lines[i];
              const start = cursor;
              const end = start + lineText.length;
              const newlineLength = i < lines.length - 1 ? 1 : 0;
              linePositions.push({
                value: lineText,
                start,
                end,
                newlineLength,
              });
              cursor = end + newlineLength;
            }
            const ranges = [];
            for (let i = 0; i < linePositions.length; i++) {
              const entry = linePositions[i];
              const trimmedValue = entry.value.trim();
              const normalizedLine = trimmedValue.toLowerCase();
              let markerType = null;
              if (normalizedLine === 'exec') {
                markerType = 'exec';
              } else if (normalizedLine === 'file update' || normalizedLine.startsWith('file update:')) {
                markerType = 'file-update';
              } else {
                continue;
              }
              const rangeStart = entry.end + entry.newlineLength;
              if (rangeStart >= text.length) {
                continue;
              }
              let rangeEnd = text.length;
              for (let j = i + 1; j < linePositions.length; j++) {
                if (linePositions[j].value.trim() === 'thinking') {
                  rangeEnd = linePositions[j].start;
                  break;
                }
              }
              if (rangeEnd <= rangeStart) {
                continue;
              }
              ranges.push({ start: rangeStart, end: rangeEnd, type: markerType });
            }
            return ranges;
          };

          const parseOutputSegments = (value) => {
            const text = value == null ? '' : String(value);
            if (!text) {
              return [];
            }
            const collapseRanges = findCollapseRanges(text);
            if (!collapseRanges.length) {
              return parseCodeAndTextSegments(text);
            }
            const segments = [];
            let cursor = 0;
            const sortedRanges = collapseRanges.slice().sort((a, b) => a.start - b.start);
            sortedRanges.forEach((range) => {
              if (cursor < range.start) {
                const chunk = text.slice(cursor, range.start);
                segments.push(...parseCodeAndTextSegments(chunk));
              }
              const collapsedStart = Math.max(cursor, range.start);
              const collapsedEnd = Math.max(collapsedStart, range.end);
              if (collapsedEnd > collapsedStart) {
                const collapsedContent = text.slice(collapsedStart, collapsedEnd);
                if (collapsedContent) {
                  const previewText = buildCodeBlockPreview(collapsedContent);
                  segments.push({
                    type: range.type,
                    content: collapsedContent,
                    preview:
                      previewText === 'Code block'
                        ? range.type === 'file-update'
                          ? 'File diff'
                          : 'Command output'
                        : previewText,
                  });
                }
              }
              cursor = Math.max(cursor, range.end);
            });
            if (cursor < text.length) {
              segments.push(...parseCodeAndTextSegments(text.slice(cursor)));
            }
            return segments;
          };

          const formatQueueTimestamp = (isoString) => {
            if (!isoString) return '--';
            try {
              return queueTimestampFormatter.format(new Date(isoString));
            } catch (error) {
              console.error('Unable to format queue timestamp', error);
              return isoString;
            }
          };

          const normalizePromptId = (value) => {
            if (value == null) {
              return '';
            }
            return String(value);
          };

          const computeRuntimeSeconds = (startIso, endIso) => {
            if (!startIso || !endIso) {
              return null;
            }
            const start = new Date(startIso);
            const end = new Date(endIso);
            const elapsedMs = end - start;
            if (!Number.isFinite(elapsedMs) || elapsedMs < 0) {
              return null;
            }
            return elapsedMs / 1000;
          };

          const getStreamState = (promptId) => {
            if (!promptId) return null;
            if (!promptStreams[promptId]) {
              promptStreams[promptId] = {
                stdout: '',
                stderr: '',
                updated_at: null,
                started_at: null,
                done: false,
              };
            }
            return promptStreams[promptId];
          };

          const clearStreamState = (promptId) => {
            if (!promptId || !promptStreams[promptId]) return;
            delete promptStreams[promptId];
            if (selectedPrompt.value?.prompt_id === promptId) {
              selectedPrompt.value = { ...selectedPrompt.value, live_stream: null };
            }
          };

          const updateQueue = (items = []) => {
            const normalized = items.map((item) => ({ ...item }));
            if (!queue.value.length) {
              queue.value = normalized;
              return;
            }
            const existingLookup = new Map(queue.value.map((entry) => [entry.prompt_id, entry]));
            const merged = normalized.map((item) => {
              const current = existingLookup.get(item.prompt_id);
              if (current) {
                Object.assign(current, item);
                return current;
              }
              return item;
            });
            queue.value.splice(0, queue.value.length, ...merged);
          };

          const mergeQueueEntry = (entry) => {
            if (!entry || !entry.prompt_id) {
              return;
            }
            const index = queue.value.findIndex((item) => item.prompt_id === entry.prompt_id);
            if (index === -1) {
              queue.value.unshift({ ...entry });
              return;
            }
            Object.assign(queue.value[index], entry);
          };

          const formatStatus = (status) => {
            if (!status) return 'Unknown';
            const normalized = status.toString().toLowerCase();
            return normalized.charAt(0).toUpperCase() + normalized.slice(1);
          };

          const isFailedStatus = (status) => (status || '').toLowerCase() === 'failed';
          const isRunningStatus = (status) => (status || '').toLowerCase() === 'running';

          const attemptLogs = computed(() => {
            if (!selectedPrompt.value?.attempt_logs?.length) {
              return [];
            }
            return [...selectedPrompt.value.attempt_logs].sort((a, b) => {
              return new Date(a.received_at || 0) - new Date(b.received_at || 0);
            });
          });

          const globalContext = computed(() => selectedPrompt.value?.agents_context || '');

          const projectLookup = computed(() => {
            const map = new Map();
            projectOptions.value.forEach((project) => {
              if (project && project.id) {
                map.set(project.id, project);
              }
            });
            return map;
          });

          const activeProjectId = computed(() => {
            const current = selectedProjectId.value;
            if (current && projectLookup.value.has(current)) {
              return current;
            }
            const fallback = defaultProjectId.value;
            if (fallback && projectLookup.value.has(fallback)) {
              return fallback;
            }
            const first = projectOptions.value.find((project) => project?.id);
            return first ? first.id : null;
          });

          const activeProject = computed(() => {
            const id = activeProjectId.value;
            if (!id) {
              return null;
            }
            return projectLookup.value.get(id) || null;
          });

          const activeProjectLaunchUrl = computed(() => activeProject.value?.launch_url || '');

          const selectedPromptProject = computed(() => {
            const prompt = selectedPrompt.value;
            if (!prompt) {
              return null;
            }
            if (prompt.project?.id) {
              return prompt.project;
            }
            if (prompt.project_id && projectLookup.value.has(prompt.project_id)) {
              return projectLookup.value.get(prompt.project_id);
            }
            return null;
          });

          const selectedPromptProjectName = computed(() => selectedPromptProject.value?.name || '');

          const activeStream = computed(() => {
            const id = selectedPrompt.value?.prompt_id;
            if (!id) return null;
            return promptStreams[id] || null;
          });

          const showLiveStream = computed(() => {
            const stream = activeStream.value;
            if (!stream) {
              return false;
            }
            if (stream.stdout || stream.stderr) {
              return true;
            }
            return !stream.done;
          });

          const liveAttemptNumber = computed(() => {
            if (!showLiveStream.value) {
              return null;
            }
            const reportedAttempts = Number(selectedPrompt.value?.attempts);
            if (Number.isFinite(reportedAttempts) && reportedAttempts > attemptLogs.value.length) {
              return reportedAttempts;
            }
            return attemptLogs.value.length + 1;
          });

          const liveAttemptReceivedAt = computed(() => {
            const stream = activeStream.value;
            if (stream?.started_at) {
              return stream.started_at;
            }
            if (selectedPrompt.value?.live_stream?.started_at) {
              return selectedPrompt.value.live_stream.started_at;
            }
            if (selectedPrompt.value?.started_at) {
              return selectedPrompt.value.started_at;
            }
            return selectedPrompt.value?.updated_at || selectedPrompt.value?.created_at || null;
          });

          const liveAttemptDurationSeconds = computed(() => {
            const stream = activeStream.value;
            const start = liveAttemptReceivedAt.value;
            if (!start) {
              return null;
            }
            const status = (selectedPrompt.value?.status || '').toLowerCase();
            if (status === 'running') {
              return computeRuntimeSeconds(start, nowTick.value);
            }
            if (stream?.updated_at) {
              return computeRuntimeSeconds(start, stream.updated_at);
            }
            if (selectedPrompt.value?.updated_at) {
              return computeRuntimeSeconds(start, selectedPrompt.value.updated_at);
            }
            return null;
          });

          const queueEntries = computed(() => {
            const lookup = projectLookup.value;
            const focusProjectId = activeProjectId.value;
            const nowMs = nowTick.value;
            return queue.value
              .map((item, index) => {
                const status = (item.status || '').toLowerCase();
                const isCompleted = status === 'completed';
                const isFailed = status === 'failed';
                const isCanceled = status === 'canceled';
                const isRunning = isRunningStatus(status);
                let runtimeSeconds = null;
                if (isCompleted || isFailed || isCanceled) {
                  runtimeSeconds = computeRuntimeSeconds(item.created_at, item.updated_at);
                } else if (isRunning) {
                  const runningStart = item.started_at || item.updated_at || item.created_at;
                  runtimeSeconds = computeRuntimeSeconds(runningStart, nowMs);
                }
                let detailSource = item.text || '';
                if (isCompleted) {
                  detailSource = item.stdout_preview || item.result_summary || '';
                } else if (isCanceled) {
                  detailSource = item.result_summary || 'Prompt canceled by user';
                }
                const normalizedDetail = normalizeWhitespace(detailSource);
                const placeholder = isCompleted
                  ? 'Stdout unavailable'
                  : isCanceled
                    ? 'Prompt canceled'
                    : 'Prompt unavailable';
                const detailLimit = isMobileLayout.value ? QUEUE_DETAIL_MOBILE_MAX : QUEUE_DETAIL_MAX;
                const detail =
                  normalizedDetail.length > detailLimit
                    ? `${normalizedDetail.slice(0, detailLimit - 1)}â€¦`
                    : normalizedDetail || placeholder;
                const entryProjectId = item.project?.id || item.project_id || null;
                if (focusProjectId && entryProjectId !== focusProjectId) {
                  return null;
                }
                return {
                  ...item,
                  queueIndex: index + 1,
                  createdDisplay: formatQueueTimestamp(item.created_at),
                  runtimeDisplay: runtimeSeconds != null ? formatQueueDuration(runtimeSeconds) : null,
                  detailLine: detail,
                };
              })
              .filter(Boolean);
          });

          watch(
            () => queueEntries.value.length,
            () => {
              refreshGuidedTourHighlight();
            }
          );

          const averagePromptDurationSeconds = computed(() => {
            if (!queue.value.length) {
              return null;
            }
            const recentEntries = queue.value.slice(0, PROMPT_AVERAGE_WINDOW);
            const durations = recentEntries
              .map((item) => {
                const status = (item.status || '').toLowerCase();
                if (!PROMPT_DURATION_STATUSES.has(status)) {
                  return null;
                }
                return computeRuntimeSeconds(item.created_at, item.updated_at);
              })
              .filter((seconds) => seconds != null);
            if (!durations.length) {
              return null;
            }
            const total = durations.reduce((sum, seconds) => sum + seconds, 0);
            const average = total / durations.length;
            return Number.isFinite(average) ? average : null;
          });

          const humanTaskEntries = computed(() => {
            const entries = humanTasks.value.map((task) => {
              const normalizedStatus = (task?.status || '').toLowerCase();
              const projectName =
                task?.project?.name ||
                task?.project?.id ||
                task?.project_id ||
                (task?.project && typeof task.project === 'string' ? task.project : '') ||
                'Unscoped';
              const description = normalizeWhitespace(task?.description || '');
              const snippet = description.length > 220 ? `${description.slice(0, 219)}â€¦` : description;
              return {
                ...task,
                statusDisplay: formatHumanTaskStatus(normalizedStatus || task?.status),
                projectDisplay: projectName,
                descriptionSnippet: snippet || 'No description provided.',
              };
            });
            return entries.sort((a, b) => {
              if (a.blocking !== b.blocking) {
                return a.blocking ? -1 : 1;
              }
              const statusRankA = HUMAN_TASK_STATUS_ORDER[a.status] ?? 99;
              const statusRankB = HUMAN_TASK_STATUS_ORDER[b.status] ?? 99;
              if (statusRankA !== statusRankB) {
                return statusRankA - statusRankB;
              }
              if (a.created_at && b.created_at) {
                return a.created_at.localeCompare(b.created_at);
              }
              return 0;
            });
          });

          const blockingHumanTaskCount = computed(() => {
            const summary = humanTasksSummary.value || {};
            return summary.blocking_count || 0;
          });

          const openHumanTaskCount = computed(() => {
            const counts = (humanTasksSummary.value && humanTasksSummary.value.status_counts) || {};
            return counts.open || 0;
          });

          const averagePromptDurationDisplay = computed(() => {
            const seconds = averagePromptDurationSeconds.value;
            if (seconds == null) {
              return 'â€”';
            }
            return formatQueueDuration(seconds);
          });

          const canEditSelectedPrompt = computed(() => {
            if (!selectedPrompt.value) {
              return false;
            }
            return (selectedPrompt.value.status || '').toLowerCase() === 'queued';
          });

          const canCancelSelectedPrompt = computed(() => {
            if (!selectedPrompt.value) {
              return false;
            }
            const status = (selectedPrompt.value.status || '').toLowerCase();
            if (status === 'queued') {
              return true;
            }
            return isRunningStatus(status);
          });
          const canRestartSelectedPrompt = computed(() => {
            if (!selectedPrompt.value) {
              return false;
            }
            return (selectedPrompt.value.status || '').toLowerCase() === 'canceled';
          });

          const attemptKey = (attempt, index) => `${attempt.received_at || 'attempt'}-${index}`;

          const resolveGuidedTourTarget = (step) => {
            if (!step || typeof document === 'undefined') {
              return null;
            }
            if (typeof step.target === 'function') {
              try {
                return step.target();
              } catch (error) {
                console.warn('Unable to resolve guided tour target', error);
                return null;
              }
            }
            if (typeof step.target === 'string' && step.target) {
              return document.querySelector(step.target);
            }
            return null;
          };

          const updateGuidedTourHighlightRect = () => {
            if (!guidedTourActive.value) {
              guidedTourHighlightRect.value = null;
              guidedTourTargetMissing.value = false;
              return;
            }
            const step = guidedTourCurrentStep.value;
            if (!step) {
              guidedTourHighlightRect.value = null;
              guidedTourTargetMissing.value = false;
              return;
            }
            const target = resolveGuidedTourTarget(step);
            if (!target) {
              guidedTourHighlightRect.value = null;
              guidedTourTargetMissing.value = true;
              return;
            }
            const rect = target.getBoundingClientRect();
            guidedTourHighlightRect.value = {
              top: rect.top,
              left: rect.left,
              width: rect.width,
              height: rect.height,
            };
            guidedTourTargetMissing.value = rect.width <= 0 || rect.height <= 0;
          };

          const refreshGuidedTourHighlight = () => {
            if (!guidedTourActive.value) {
              return;
            }
            nextTick(() => updateGuidedTourHighlightRect());
          };

          const startGuidedTour = () => {
            if (!canStartGuidedTour.value || !GUIDED_TOUR_STEPS.length) {
              return;
            }
            guidedTourStepIndex.value = 0;
            guidedTourActive.value = true;
            guidedTourTargetMissing.value = false;
            refreshGuidedTourHighlight();
          };

          const closeGuidedTour = () => {
            guidedTourActive.value = false;
            guidedTourHighlightRect.value = null;
            guidedTourTargetMissing.value = false;
          };

          const previousGuidedTourStep = () => {
            if (guidedTourStepIndex.value === 0) {
              return;
            }
            guidedTourStepIndex.value -= 1;
            refreshGuidedTourHighlight();
          };

          const advanceGuidedTour = () => {
            if (isGuidedTourLastStep.value) {
              closeGuidedTour();
              return;
            }
            guidedTourStepIndex.value = Math.min(
              guidedTourStepIndex.value + 1,
              Math.max(0, GUIDED_TOUR_STEPS.length - 1)
            );
            refreshGuidedTourHighlight();
          };

          const copyToClipboard = async (value) => {
            const text = value == null ? '' : String(value);
            try {
              await navigator.clipboard.writeText(text);
            } catch (error) {
              const textarea = document.createElement('textarea');
              textarea.value = text;
              textarea.style.position = 'fixed';
              textarea.style.opacity = '0';
              textarea.style.pointerEvents = 'none';
              document.body.appendChild(textarea);
              textarea.focus();
              textarea.select();
              try {
                document.execCommand('copy');
              } finally {
                textarea.remove();
              }
            }
          };

          const updateChatThreadHeight = () => {
            chatThreadHeight.value = chatThreadRef.value?.clientHeight || 0;
          };

          const updateViewportWidth = () => {
            viewportWidth.value = typeof window !== 'undefined' ? window.innerWidth : viewportWidth.value;
          };

          const handleWindowResize = () => {
            updateChatThreadHeight();
            updateViewportWidth();
            refreshGuidedTourHighlight();
          };

          const handleGuidedTourScroll = () => {
            if (guidedTourActive.value) {
              updateGuidedTourHighlightRect();
            }
          };

          const scrollElementToBottom = (elementRef) => {
            nextTick(() => {
              const target = elementRef?.value;
              if (target) {
                target.scrollTop = target.scrollHeight;
              }
            });
          };

          const scrollChatThreadToBottom = () => {
            scrollElementToBottom(chatThreadRef);
          };

          const scrollLiveStreamToBottom = () => {
            scrollElementToBottom(liveStreamScrollRef);
          };

          watch(
            () => chatThreadRef.value,
            (element) => {
              if (chatThreadResizeObserver) {
                chatThreadResizeObserver.disconnect();
                chatThreadResizeObserver = null;
              }
              if (element && typeof ResizeObserver !== 'undefined') {
                chatThreadResizeObserver = new ResizeObserver(() => updateChatThreadHeight());
                chatThreadResizeObserver.observe(element);
              }
              nextTick(() => updateChatThreadHeight());
            },
            { immediate: true }
          );

          watch(attemptLogs, () => {
            scrollChatThreadToBottom();
          });

          watch(
            () => selectedPrompt.value?.prompt_id,
            () => {
              nextTick(() => {
                updateChatThreadHeight();
              });
            }
          );

          watch(
            () => selectedPrompt.value?.prompt_id,
            (promptId, previousId) => {
              if (
                editPromptDialogVisible.value &&
                (promptId !== previousId || !promptId)
              ) {
                clearEditPromptState();
              }
            }
          );

          watch(
            () => selectedPrompt.value?.status,
            (status) => {
              if (
                editPromptDialogVisible.value &&
                (status || '').toLowerCase() !== 'queued'
              ) {
                clearEditPromptState();
              }
            }
          );

          watch(showLiveStream, (visible) => {
            nextTick(() => {
              updateChatThreadHeight();
            });
            if (visible) {
              scrollLiveStreamToBottom();
            }
          });

          watch(
            () => [activeStream.value?.stdout, activeStream.value?.stderr],
            () => {
              scrollChatThreadToBottom();
              scrollLiveStreamToBottom();
            }
          );

          watch(
            isAuthenticated,
            (authed) => {
              if (authed) {
                fetchProgressLog();
                startLogRefresh();
                fetchHumanTasks({ silent: true }).catch(() => {});
              } else {
                stopLogRefresh();
                operationsLog.value = '';
                logLastUpdated.value = '';
                logError.value = '';
                logLoading.value = false;
                activeView.value = 'queue';
                resetSettingsState();
                humanTasks.value = [];
                humanTasksSummary.value = {};
                humanTasksRevision.value = null;
                humanTasksError.value = '';
                humanTasksLoading.value = false;
              }
            },
            { immediate: true }
          );

          watch(
            () => [isAuthenticated.value, route.name, route.params.promptId],
            async ([authed, routeName, routePrompt]) => {
              if (!authed || routeName !== 'queue') {
                return;
              }
              const normalizedId = normalizePromptId(routePrompt).trim();
              if (!normalizedId) {
                if (selectedPrompt.value) {
                  selectedPrompt.value = null;
                }
                return;
              }
              if (selectedPrompt.value?.prompt_id === normalizedId) {
                return;
              }
              try {
                await selectPrompt(normalizedId, { updateRoute: false });
              } catch (error) {
                console.error('Unable to restore prompt from route', error);
              }
            },
            { immediate: true }
          );

          const fetchProjects = async () => {
            try {
              const data = await api('/api/projects');
              const items = Array.isArray(data?.projects) ? data.projects : [];
              projectOptions.value = items;
              defaultProjectId.value = data?.default_project_id || null;
              applyProjectSelection();
            } catch (error) {
              console.error('Unable to load projects', error);
              projectOptions.value = [];
              defaultProjectId.value = null;
              selectedProjectId.value = '';
            }
          };

          const fetchPrompts = async (options = {}) => {
            if (!isAuthenticated.value) {
              loading.value = false;
              return;
            }
            const { silent = false } = options;
            if (!silent) {
              loading.value = true;
            }
            try {
              const data = await api('/api/prompts');
              updateQueue(data.items || []);
            } catch (error) {
              console.error(error);
            } finally {
              if (!silent) {
                loading.value = false;
              }
            }
          };

          const fetchHumanTasks = async (options = {}) => {
            if (!isAuthenticated.value) {
              return;
            }
            const { silent = false } = options;
            if (!silent) {
              humanTasksLoading.value = true;
            }
            humanTasksError.value = '';
            try {
              const data = await api('/api/human_tasks');
              const items = Array.isArray(data?.tasks) ? data.tasks : [];
              humanTasks.value = items;
              if (data?.summary) {
                humanTasksSummary.value = data.summary;
              }
              const revisionValue =
                typeof data?.revision === 'number'
                  ? data.revision
                  : typeof data?.summary?.revision === 'number'
                    ? data.summary.revision
                    : null;
              if (revisionValue != null) {
                humanTasksRevision.value = revisionValue;
              }
            } catch (error) {
              humanTasksError.value = error.message || 'Unable to load human tasks';
            } finally {
              if (!silent) {
                humanTasksLoading.value = false;
              }
            }
          };

          const refreshHumanTasks = () => {
            fetchHumanTasks().catch(() => {});
          };

          const fetchHealth = async () => {
            if (!isAuthenticated.value) {
              return;
            }
            try {
              const data = await api('/api/health');
              health.value = data;
              if (data?.user) {
                currentUser.value = data.user;
              }
              applyHumanTaskMetrics(data?.metrics?.human_tasks);
            } catch (error) {
              console.error(error);
            }
          };

          const applyHumanTaskMetrics = (metrics) => {
            if (!metrics || typeof metrics !== 'object') {
              return;
            }
            humanTasksSummary.value = { ...metrics };
            const revision = typeof metrics.revision === 'number' ? metrics.revision : null;
            if (!isAuthenticated.value) {
              return;
            }
            if (revision == null) {
              return;
            }
            if (humanTasksRevision.value == null) {
              humanTasksRevision.value = revision;
              fetchHumanTasks({ silent: true }).catch(() => {});
              return;
            }
            if (revision !== humanTasksRevision.value) {
              humanTasksRevision.value = revision;
              fetchHumanTasks({ silent: true }).catch(() => {});
            }
          };

          const fetchProgressLog = async (options = {}) => {
            if (!isAuthenticated.value) {
              return;
            }
            const { silent = false } = options;
            if (!silent) {
              logLoading.value = true;
            }
            logError.value = '';
            try {
              const data = await api('/api/logs');
              const rawLog = data?.log || '';
              const lines = rawLog ? rawLog.split(/\r?\n/) : [];
              while (lines.length && lines[lines.length - 1] === '') {
                lines.pop();
              }
              operationsLog.value = lines.reverse().join('\n');
              logLastUpdated.value = new Date().toISOString();
            } catch (error) {
              logError.value = error.message || 'Unable to load progress log';
            } finally {
              if (!silent) {
                logLoading.value = false;
              }
            }
          };

          const startLogRefresh = () => {
            clearLogRefreshTimer();
            if (!isAuthenticated.value) {
              return;
            }
            logRefreshTimer = setInterval(() => {
              fetchProgressLog({ silent: true }).catch(() => {});
            }, LOG_REFRESH_INTERVAL_MS);
          };

          const refreshProgressLog = () => {
            fetchProgressLog();
          };

          const changePassword = async () => {
            if (!isAuthenticated.value || passwordChangeLoading.value) {
              return;
            }
            if (!passwordForm.current || !passwordForm.newValue || !passwordForm.confirm) {
              passwordChangeError.value = 'All password fields are required';
              passwordChangeSuccess.value = '';
              return;
            }
            if (passwordForm.newValue !== passwordForm.confirm) {
              passwordChangeError.value = 'New password and confirmation do not match';
              passwordChangeSuccess.value = '';
              return;
            }
            if (passwordForm.newValue.length < 8) {
              passwordChangeError.value = 'New password must be at least 8 characters';
              passwordChangeSuccess.value = '';
              return;
            }
            if (passwordForm.newValue === passwordForm.current) {
              passwordChangeError.value = 'New password must be different from the current password';
              passwordChangeSuccess.value = '';
              return;
            }
            passwordChangeError.value = '';
            passwordChangeSuccess.value = '';
            passwordChangeLoading.value = true;
            try {
              await api('/api/user/password', {
                method: 'POST',
                body: JSON.stringify({
                  current_password: passwordForm.current,
                  new_password: passwordForm.newValue,
                }),
              });
              passwordChangeSuccess.value = 'Password updated successfully.';
              resetPasswordForm();
            } catch (error) {
              passwordChangeError.value = error.message || 'Unable to change password';
            } finally {
              passwordChangeLoading.value = false;
            }
          };

          const fetchSshKeys = async () => {
            if (!isAuthenticated.value) {
              return;
            }
            sshKeysLoading.value = true;
            sshKeysError.value = '';
            try {
              const response = await api('/api/user/ssh_keys');
              const items = Array.isArray(response?.keys) ? response.keys : [];
              sshKeys.value = items;
              sshKeysLastFetched.value = new Date().toISOString();
            } catch (error) {
              sshKeys.value = [];
              sshKeysError.value = error.message || 'Unable to load SSH keys';
            } finally {
              sshKeysLoading.value = false;
            }
          };

          watch(
            () => activeView.value,
            (view) => {
              if (view === 'settings') {
                fetchSshKeys();
              }
            }
          );

          const submitPrompt = async () => {
            if (!isAuthenticated.value || !promptText.value.trim()) return;
            submitting.value = true;
            try {
              const payload = { prompt: promptText.value };
              if (activeProjectId.value) {
                payload.project_id = activeProjectId.value;
              }
              const response = await api('/api/prompts', {
                method: 'POST',
                body: JSON.stringify(payload),
              });
              promptText.value = '';
              if (response?.prompt_id) {
                await selectPrompt({ prompt_id: response.prompt_id });
              }
              if (!realtimeReady.value) {
                await fetchPrompts({ silent: true });
              }
            } catch (error) {
              alert(error.message);
            } finally {
              submitting.value = false;
            }
          };

          const queueHeaderIconRefreshTask = async () => {
            if (!isAuthenticated.value || headerIconRequesting.value) {
              return false;
            }
            headerIconRequesting.value = true;
            const prompt = [
              'Design refreshed Nightshift header icon and favicon assets.',
              'Match the geometric neon style from frontend/logo.svg and frontend/favicon.svg, maintaining the dark theme palette.',
              'Deliver SVG files for a 36x36 header icon and a 32x32 favicon, along with guidance on colors, stroke weights, spacing, and any simplified fallback marks.',
              'Explain how to drop the new assets into the existing Vue/Vuetify header without additional layout changes.',
            ].join(' ');
            try {
              const payload = { prompt };
              if (activeProjectId.value) {
                payload.project_id = activeProjectId.value;
              }
              const response = await api('/api/prompts', {
                method: 'POST',
                body: JSON.stringify(payload),
              });
              if (response?.prompt_id) {
                await selectPrompt({ prompt_id: response.prompt_id });
              }
              if (!realtimeReady.value) {
                await fetchPrompts({ silent: true });
              }
              return true;
            } catch (error) {
              alert(error.message || 'Unable to queue the branding refresh task');
              return false;
            } finally {
              headerIconRequesting.value = false;
            }
          };

          const handleComposerKeydown = (event) => {
            if (event.shiftKey) {
              return;
            }
            event.preventDefault();
            if (!promptText.value.trim() || submitting.value) {
              return;
            }
            submitPrompt();
          };

          const refreshSelectedPrompt = async (promptId) => {
            if (!isAuthenticated.value) return;
            const targetId = promptId || selectedPrompt.value?.prompt_id;
            if (!targetId) return;
            if (realtimeReady.value && sendRealtimeMessage({ type: 'fetch_prompt', prompt_id: targetId })) {
              return;
            }
            try {
              const data = await api(`/api/prompts/${targetId}`);
              if (!selectedPrompt.value || selectedPrompt.value.prompt_id === targetId) {
                selectedPrompt.value = data;
              }
            } catch (error) {
              console.error(error);
            }
          };

          const selectPrompt = async (prompt, options = {}) => {
            if (!prompt) return;
            const { updateRoute = true } = options;
            const promptId =
              typeof prompt === 'string' ? normalizePromptId(prompt) : normalizePromptId(prompt.prompt_id);
            if (!promptId) {
              return;
            }
            const matchingEntry =
              typeof prompt === 'object' && prompt.prompt_id
                ? prompt
                : queue.value.find((item) => item.prompt_id === promptId);
            if (!selectedPrompt.value || selectedPrompt.value.prompt_id !== promptId) {
              selectedPrompt.value = matchingEntry ? { ...matchingEntry } : { prompt_id: promptId };
            } else if (matchingEntry) {
              selectedPrompt.value = { ...selectedPrompt.value, ...matchingEntry };
            }
            if (updateRoute && route.params.promptId !== promptId) {
              router.replace({ name: 'queue', params: { promptId } }).catch(() => {});
            }
            await refreshSelectedPrompt(promptId);
            if (isMobileLayout.value) {
              activeMobilePanel.value = 'thread';
            }
          };

          const queuePromptRetry = async (stateRef, errorMessage) => {
            const currentId = selectedPrompt.value?.prompt_id;
            if (!currentId || stateRef.value) {
              return;
            }
            stateRef.value = true;
            try {
              await api(`/api/prompts/${currentId}/retry`, { method: 'POST' });
              if (!realtimeReady.value) {
                await fetchPrompts({ silent: true });
              }
              const refreshed = queue.value.find((item) => item.prompt_id === currentId) || { prompt_id: currentId };
              await selectPrompt(refreshed);
            } catch (error) {
              alert(error.message || errorMessage);
            } finally {
              stateRef.value = false;
            }
          };

          const retryPrompt = async () => {
            if (!isAuthenticated.value || !selectedPrompt.value) return;
            await queuePromptRetry(retrying, 'Unable to retry prompt');
          };

          const restartSelectedPrompt = async () => {
            if (!isAuthenticated.value || !selectedPrompt.value || !canRestartSelectedPrompt.value) {
              return;
            }
            await queuePromptRetry(restarting, 'Unable to restart prompt');
          };

          const performCancelAction = async () => {
            if (!isAuthenticated.value || !selectedPrompt.value || !canCancelSelectedPrompt.value) {
              return;
            }
            if (canceling.value) {
              return;
            }
            const status = (selectedPrompt.value.status || '').toLowerCase();
            if (status === 'queued') {
              const confirmed =
                typeof window === 'undefined' ? true : window.confirm('Cancel this queued prompt?');
              if (!confirmed) {
                return;
              }
            }
            canceling.value = true;
            const promptId = selectedPrompt.value.prompt_id;
            try {
              if (status === 'queued') {
                await api(`/api/prompts/${promptId}`, { method: 'DELETE' });
                const index = queue.value.findIndex((entry) => entry.prompt_id === promptId);
                if (index !== -1) {
                  queue.value.splice(index, 1);
                }
                clearStreamState(promptId);
                selectedPrompt.value = null;
                router.replace({ name: 'queue' }).catch(() => {});
              } else {
                await api(`/api/prompts/${promptId}/cancel`, {
                  method: 'POST',
                  body: JSON.stringify({ restart: false }),
                });
              }
              if (!realtimeReady.value) {
                await fetchPrompts({ silent: true });
              }
            } catch (error) {
              const fallbackMessage = status === 'queued' ? 'Unable to delete prompt' : 'Unable to cancel prompt';
              alert(error.message || fallbackMessage);
            } finally {
              canceling.value = false;
            }
          };

          const cancelSelectedPrompt = () => performCancelAction();

          const clearEditPromptState = () => {
            editPromptDialogVisible.value = false;
            editPromptText.value = '';
            editPromptError.value = '';
          };

          const openEditPromptDialog = () => {
            if (!canEditSelectedPrompt.value || !selectedPrompt.value) {
              return;
            }
            editPromptText.value = selectedPrompt.value.text || '';
            editPromptError.value = '';
            editPromptDialogVisible.value = true;
          };

          const cancelEditPrompt = () => {
            if (editPromptSaving.value) {
              return;
            }
            clearEditPromptState();
          };

          const savePromptEdit = async () => {
            if (!isAuthenticated.value || !canEditSelectedPrompt.value || !selectedPrompt.value) {
              return;
            }
            const trimmed = editPromptText.value.trim();
            if (!trimmed) {
              editPromptError.value = 'Prompt text is required';
              return;
            }
            editPromptSaving.value = true;
            editPromptError.value = '';
            try {
              const response = await api(`/api/prompts/${selectedPrompt.value.prompt_id}`, {
                method: 'PUT',
                body: JSON.stringify({ prompt: trimmed }),
              });
              const updated = response?.prompt;
              if (updated && updated.prompt_id === selectedPrompt.value.prompt_id) {
                selectedPrompt.value = { ...selectedPrompt.value, ...updated };
              } else {
                selectedPrompt.value = { ...(selectedPrompt.value || {}), text: trimmed };
              }
              const queueIndex = queue.value.findIndex(
                (entry) => entry.prompt_id === selectedPrompt.value?.prompt_id
              );
              if (queueIndex !== -1) {
                const replacement = { ...queue.value[queueIndex], text: trimmed };
                queue.value.splice(queueIndex, 1, replacement);
              }
              if (!realtimeReady.value) {
                await fetchPrompts({ silent: true });
              }
              clearEditPromptState();
            } catch (error) {
              editPromptError.value = error.message || 'Unable to update prompt';
            } finally {
              editPromptSaving.value = false;
            }
          };

          const login = async () => {
            const email = loginEmail.value.trim();
            if (loginLoading.value) {
              return;
            }
            if (!email || !loginPassword.value) {
              loginError.value = 'Email and password are required';
              return;
            }
            loginLoading.value = true;
            loginError.value = '';
            try {
              const response = await fetch('/api/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ email, password: loginPassword.value }),
              });
              const payload = await response.json().catch(() => ({}));
              if (!response.ok) {
                throw new Error(payload.error || 'Unable to sign in');
              }
              if (!payload.token) {
                throw new Error('Login response missing token');
              }
              authToken.value = payload.token;
              currentUser.value = payload.user || { email };
              loginPassword.value = '';
              persistToken(payload.token);
              connectRealtime();
              await fetchPrompts();
              await fetchHealth();
              await fetchHumanTasks();
            } catch (error) {
              handleUnauthorized();
              loginError.value = error.message || 'Unable to sign in';
            } finally {
              loginLoading.value = false;
            }
          };

          const togglePasswordVisibility = () => {
            showPassword.value = !showPassword.value;
          };

          const logout = () => {
            handleUnauthorized();
            loginPassword.value = '';
            loginError.value = '';
          };

          const persistThemePreference = async (mode) => {
            const normalized = mode === 'dark' ? 'dark' : mode === 'light' ? 'light' : '';
            if (!normalized || typeof fetch === 'undefined') {
              return;
            }
            const headers = { 'Content-Type': 'application/json' };
            if (authToken.value) {
              headers.Authorization = `Bearer ${authToken.value}`;
            }
            try {
              await fetch('/api/preferences/theme', {
                method: 'PUT',
                headers,
                body: JSON.stringify({ mode: normalized }),
              });
            } catch (error) {
              console.warn('Unable to sync server theme preference', error);
            }
          };

          const updateFaviconLinks = (mode) => {
            if (typeof document === 'undefined') {
              return;
            }
            const sources = FAVICON_SOURCES[mode] || FAVICON_SOURCES.dark;
            Object.entries(sources).forEach(([variant, config]) => {
              if (!config) {
                return;
              }
              const link = document.querySelector(`link[data-nightshift-favicon='${variant}']`);
              if (!link) {
                return;
              }
              link.setAttribute('href', config.href);
              link.setAttribute('type', config.type);
              if (config.sizes) {
                link.setAttribute('sizes', config.sizes);
              } else {
                link.removeAttribute('sizes');
              }
            });
          };

          const applyTheme = (mode) => {
            themeMode.value = mode;
            theme.global.name.value = mode;
            if (typeof document !== 'undefined') {
              document.documentElement.setAttribute('data-theme', mode);
            }
            updateFaviconLinks(mode);
            if (typeof window !== 'undefined' && window.localStorage) {
              try {
                window.localStorage.setItem(THEME_STORAGE_KEY, mode);
              } catch (error) {
                console.warn('Unable to persist theme preference', error);
              }
            }
            persistThemePreference(mode);
          };

          const initTheme = () => {
            let preferred = themeMode.value;
            if (typeof window !== 'undefined' && window.localStorage) {
              try {
                const stored = window.localStorage.getItem(THEME_STORAGE_KEY);
                if (stored === 'light' || stored === 'dark') {
                  preferred = stored;
                }
              } catch (error) {
                console.warn('Unable to read stored theme preference', error);
              }
            }
            applyTheme(preferred);
          };

          const toggleTheme = () => {
            const next = themeMode.value === 'dark' ? 'light' : 'dark';
            applyTheme(next);
          };

          onMounted(async () => {
            initTheme();
            if (!elapsedTimer) {
              elapsedTimer = setInterval(() => {
                nowTick.value = Date.now();
              }, 1000);
            }
            fetchProjects().catch(() => {});
            if (typeof window !== 'undefined') {
              updateViewportWidth();
              window.addEventListener('resize', handleWindowResize);
              window.addEventListener('scroll', handleGuidedTourScroll, true);
            }
            if (typeof window !== 'undefined' && window.localStorage) {
              try {
                const storedToken = window.localStorage.getItem(AUTH_TOKEN_KEY);
                if (storedToken) {
                  authToken.value = storedToken;
                  connectRealtime();
                  await fetchPrompts({ silent: true });
                  await fetchHealth();
                  await fetchHumanTasks({ silent: true });
                  loading.value = false;
                  return;
                }
              } catch (error) {
                console.warn('Unable to restore auth token', error);
              }
            }
            loading.value = false;
          });

          onUnmounted(() => {
            disconnectRealtime({ manual: true });
            stopLogRefresh();
            if (elapsedTimer) {
              clearInterval(elapsedTimer);
              elapsedTimer = null;
            }
            if (chatThreadResizeObserver) {
              chatThreadResizeObserver.disconnect();
              chatThreadResizeObserver = null;
            }
            if (typeof window !== 'undefined') {
              window.removeEventListener('resize', handleWindowResize);
              window.removeEventListener('scroll', handleGuidedTourScroll, true);
            }
          });

          return {
            promptText,
            queue,
            queueEntries,
            averagePromptDurationDisplay,
            projectOptions,
            selectedProjectId,
            activeProjectLaunchUrl,
            activeProjectId,
            canEditSelectedPrompt,
            canRestartSelectedPrompt,
            selectedPrompt,
            isMobileLayout,
            activeMobilePanel,
            loading,
            submitting,
            health,
            humanTaskEntries,
            humanTasksLoading,
            humanTasksError,
            blockingHumanTaskCount,
            openHumanTaskCount,
            refreshHumanTasks,
            retrying,
            canceling,
            restarting,
            formatDate,
            submitPrompt,
            selectPrompt,
            retryPrompt,
            canCancelSelectedPrompt,
            cancelSelectedPrompt,
            restartSelectedPrompt,
            copyToClipboard,
            attemptLogs,
            attemptKey,
            globalContext,
            selectedPromptProjectName,
            activeStream,
            showLiveStream,
            liveAttemptNumber,
            liveAttemptReceivedAt,
            liveAttemptDurationSeconds,
            activeView,
            openSettingsView,
            returnToQueueView,
            goHome,
            handleHeaderIconClick,
            showQueuePanel,
            showThreadPanel,
            startGuidedTour,
            closeGuidedTour,
            previousGuidedTourStep,
            advanceGuidedTour,
            guidedTourVisible,
            guidedTourHighlightStyle,
            guidedTourStepNumber,
            guidedTourTotalSteps,
            guidedTourCurrentStep,
            guidedTourTargetMissing,
            isGuidedTourLastStep,
            canStartGuidedTour,
            passwordForm,
            passwordChangeLoading,
            passwordChangeError,
            passwordChangeSuccess,
            sshKeys,
            sshKeysLoading,
            sshKeysError,
            sshKeysLastFetched,
            canSubmitPassword,
            changePassword,
            fetchSshKeys,
            themeMode,
            headerIconSrc,
            toggleTheme,
            chatThreadRef,
            liveStreamScrollRef,
            formatTimestamp,
            formatDuration,
            formatStatus,
            handleComposerKeydown,
            isAuthenticated,
            loginEmail,
            loginPassword,
            showPassword,
            togglePasswordVisibility,
            loginLoading,
            loginError,
            login,
            logout,
            currentUser,
            wsStatus,
            operationsLog,
            logLoading,
            logError,
            logLastUpdated,
            refreshProgressLog,
            parseOutputSegments,
            editPromptDialogVisible,
            editPromptText,
            editPromptError,
            editPromptSaving,
            openEditPromptDialog,
            cancelEditPrompt,
            savePromptEdit,
          };
        },
        template: `
          <v-app>
            <v-dialog v-model="editPromptDialogVisible" max-width="640">
              <v-card>
                <v-card-title>Edit Prompt</v-card-title>
                <v-card-text>
                  <p class="text-body-2 text-medium-emphasis mb-3">
                    Update the queued prompt before Codex begins processing it.
                  </p>
                  <v-alert v-if="editPromptError" type="error" variant="tonal" class="mb-3">
                    {{ editPromptError }}
                  </v-alert>
                  <v-textarea
                    v-model="editPromptText"
                    variant="outlined"
                    rows="4"
                    auto-grow
                    hide-details
                    placeholder="Revise the queued prompt text"
                  />
                </v-card-text>
                <v-card-actions>
                  <v-spacer />
                  <v-btn variant="text" :disabled="editPromptSaving" @click="cancelEditPrompt">Cancel</v-btn>
                  <v-btn
                    color="primary"
                    :loading="editPromptSaving"
                    :disabled="editPromptSaving || !editPromptText.trim()"
                    @click="savePromptEdit"
                  >
                    Save
                  </v-btn>
                </v-card-actions>
              </v-card>
            </v-dialog>
              <v-app-bar class="global-header" flat>
                <v-app-bar-title>
                  <div class="global-header__branding">
                    <button type="button" class="global-header__home-link" @click="goHome">
                      <img
                        :src="headerIconSrc"
                        alt="Nightshift"
                        class="global-header__logo"
                        width="36"
                        height="36"
                        title="Request refreshed header icon & favicon"
                        @click.stop.prevent="handleHeaderIconClick"
                      />
                      <span class="global-header__title">Nightshift</span>
                    </button>
                    <v-btn
                      v-if="isAuthenticated"
                      class="guided-tour-trigger"
                      variant="tonal"
                      density="compact"
                      size="x-small"
                      prepend-icon="mdi-compass-outline"
                      :title="
                        canStartGuidedTour
                          ? 'Step through what each panel does'
                          : 'Guided tour is only available on the main dashboard in desktop layout'
                      "
                      :disabled="!canStartGuidedTour"
                      @click="startGuidedTour"
                    >
                      Take tour
                    </v-btn>
                  </div>
                </v-app-bar-title>
                <v-spacer />
                <div class="header-menus">
                  <div v-if="isAuthenticated" class="user-summary">
                    <v-menu location="bottom end" transition="scale-transition">
                      <template #activator="{ props }">
                        <v-btn
                          v-bind="props"
                          variant="text"
                          class="user-menu__activator"
                          density="comfortable"
                        >
                          <span class="user-summary__email">
                            {{ (currentUser && (currentUser.name || currentUser.email)) || 'Signed in' }}
                          </span>
                          <span class="mdi mdi-menu-down" aria-hidden="true"></span>
                        </v-btn>
                      </template>
                      <v-card class="user-menu-card" elevation="8">
                        <v-list density="compact">
                          <v-list-item class="settings-menu-item" @click="openSettingsView">
                            <template #prepend>
                              <span class="user-menu-icon mdi mdi-account-cog" aria-hidden="true"></span>
                            </template>
                            <v-list-item-title>Settings</v-list-item-title>
                          </v-list-item>
                          <v-divider class="my-1" />
                          <v-list-item class="logout-list-item" @click="logout">
                            <template #prepend>
                              <span class="user-menu-icon mdi mdi-logout" aria-hidden="true"></span>
                            </template>
                            <v-list-item-title>Sign out</v-list-item-title>
                            <template #append>
                              <button
                                class="theme-toggle logout-theme-toggle"
                                type="button"
                                role="switch"
                                :aria-checked="themeMode === 'dark'"
                                :aria-label="themeMode === 'dark' ? 'Switch to light mode' : 'Switch to dark mode'"
                                @click.stop="toggleTheme"
                                @keydown.enter.prevent.stop="toggleTheme"
                                @keydown.space.prevent.stop="toggleTheme"
                              >
                                <span class="theme-toggle__icon mdi mdi-white-balance-sunny" aria-hidden="true"></span>
                                <span class="theme-toggle__icon mdi mdi-weather-night" aria-hidden="true"></span>
                                <span class="theme-toggle__thumb" :class="{ 'theme-toggle__thumb--right': themeMode === 'dark' }">
                                  <span
                                    :class="['mdi', themeMode === 'dark' ? 'mdi-weather-night' : 'mdi-white-balance-sunny']"
                                    aria-hidden="true"
                                  ></span>
                                </span>
                              </button>
                            </template>
                          </v-list-item>
                        </v-list>
                      </v-card>
                    </v-menu>
                  </div>
                  <button
                    v-else
                    class="theme-toggle ml-3 header-theme-toggle"
                    type="button"
                    role="switch"
                    :aria-checked="themeMode === 'dark'"
                    :aria-label="themeMode === 'dark' ? 'Switch to light mode' : 'Switch to dark mode'"
                    @click="toggleTheme"
                    @keydown.enter.prevent="toggleTheme"
                    @keydown.space.prevent="toggleTheme"
                  >
                    <span class="theme-toggle__icon mdi mdi-white-balance-sunny" aria-hidden="true"></span>
                    <span class="theme-toggle__icon mdi mdi-weather-night" aria-hidden="true"></span>
                    <span class="theme-toggle__thumb" :class="{ 'theme-toggle__thumb--right': themeMode === 'dark' }">
                      <span
                        :class="['mdi', themeMode === 'dark' ? 'mdi-weather-night' : 'mdi-white-balance-sunny']"
                        aria-hidden="true"
                      ></span>
                    </span>
                  </button>
                </div>
            </v-app-bar>
            <v-main>
              <v-container v-if="!isAuthenticated" class="login-container" fluid>
                <div class="login-wrapper">
                  <v-card elevation="0" class="panel-card login-card">
                    <v-card-title>Sign In</v-card-title>
                    <v-card-text>
                      <p class="text-body-2 text-medium-emphasis mb-4">
                        Use your email credentials to access the Task queue.
                      </p>
                      <v-alert
                        v-if="loginError"
                        type="error"
                        variant="tonal"
                        border="start"
                        density="comfortable"
                        class="mb-4"
                      >
                        {{ loginError }}
                      </v-alert>
                      <v-text-field
                        v-model="loginEmail"
                        label="Email"
                        type="email"
                        autocomplete="email"
                        prepend-inner-icon="mdi-email"
                        variant="outlined"
                        density="comfortable"
                        hide-details="auto"
                      />
                      <v-text-field
                        v-model="loginPassword"
                        label="Password"
                        :type="showPassword ? 'text' : 'password'"
                        autocomplete="current-password"
                        prepend-inner-icon="mdi-lock"
                        :append-inner-icon="showPassword ? 'mdi-eye-off' : 'mdi-eye'"
                        @click:append-inner="togglePasswordVisibility"
                        variant="outlined"
                        density="comfortable"
                        hide-details="auto"
                        @keydown.enter.prevent="login"
                      />
                    </v-card-text>
                    <v-card-actions>
                      <v-spacer />
                      <v-btn
                        color="primary"
                        :loading="loginLoading"
                        :disabled="!loginEmail || !loginPassword"
                        @click="login"
                      >
                        Sign In
                      </v-btn>
                    </v-card-actions>
                  </v-card>
                </div>
              </v-container>
              <v-container v-else-if="activeView === 'settings'" class="py-6 main-layout" fluid>
                <v-row class="settings-row" justify="center">
                  <v-col cols="12" md="5" lg="4">
                    <v-card elevation="0" class="panel-card">
                      <v-card-title class="d-flex align-center">
                        <div>
                          <div class="text-h6">Settings</div>
                          <div class="text-caption text-medium-emphasis">
                            Manage your account preferences.
                          </div>
                        </div>
                      </v-card-title>
                      <v-divider />
                      <v-card-text>
                        <p class="text-body-2 text-medium-emphasis mb-4">
                          Change the password for {{ currentUser ? currentUser.email : 'your account' }}.
                        </p>
                        <v-alert
                          v-if="passwordChangeError"
                          type="error"
                          variant="tonal"
                          border="start"
                          density="comfortable"
                          class="mb-4"
                        >
                          {{ passwordChangeError }}
                        </v-alert>
                        <v-alert
                          v-if="passwordChangeSuccess"
                          type="success"
                          variant="tonal"
                          border="start"
                          density="comfortable"
                          class="mb-4"
                        >
                          {{ passwordChangeSuccess }}
                        </v-alert>
                        <v-text-field
                          v-model="passwordForm.current"
                          label="Current password"
                          type="password"
                          autocomplete="current-password"
                          prepend-inner-icon="mdi-lock"
                          variant="outlined"
                          density="comfortable"
                          hide-details="auto"
                          class="mb-3"
                        />
                        <v-text-field
                          v-model="passwordForm.newValue"
                          label="New password"
                          type="password"
                          autocomplete="new-password"
                          prepend-inner-icon="mdi-lock-check"
                          variant="outlined"
                          density="comfortable"
                          hide-details="auto"
                          class="mb-3"
                        />
                        <v-text-field
                          v-model="passwordForm.confirm"
                          label="Confirm new password"
                          type="password"
                          autocomplete="new-password"
                          prepend-inner-icon="mdi-lock-reset"
                          variant="outlined"
                          density="comfortable"
                          hide-details="auto"
                        />
                      </v-card-text>
                      <v-card-actions>
                        <v-spacer />
                        <v-btn
                          color="primary"
                          :loading="passwordChangeLoading"
                          :disabled="!canSubmitPassword || passwordChangeLoading"
                          @click="changePassword"
                        >
                          Update password
                        </v-btn>
                      </v-card-actions>
                      <v-divider class="mx-4" />
                      <v-card-text>
                        <div class="d-flex align-center mb-2">
                          <div>
                            <div class="text-subtitle-1">SSH Public Keys</div>
                            <div class="text-body-2 text-medium-emphasis">
                              Add these keys to GitHub or any other git hosting service.
                            </div>
                          </div>
                          <v-spacer />
                          <v-btn
                            variant="text"
                            size="small"
                            :loading="sshKeysLoading"
                            :disabled="sshKeysLoading"
                            icon="mdi-refresh"
                            @click="fetchSshKeys"
                            :aria-label="sshKeysLoading ? 'Refreshing keys' : 'Refresh keys'"
                          ></v-btn>
                        </div>
                        <div class="text-caption text-medium-emphasis mb-4" v-if="sshKeysLastFetched">
                          Last refreshed {{ formatTimestamp(sshKeysLastFetched) }}
                        </div>
                        <v-alert
                          v-if="sshKeysError"
                          type="error"
                          variant="tonal"
                          border="start"
                          density="comfortable"
                          class="mb-4"
                        >
                          {{ sshKeysError }}
                        </v-alert>
                        <v-skeleton-loader
                          v-if="sshKeysLoading && !sshKeys.length && !sshKeysError"
                          type="list-item-two-line@2"
                        />
                        <div v-else class="ssh-key-list">
                          <div v-if="!sshKeys.length" class="text-body-2 text-medium-emphasis">
                            No SSH keys are available yet.
                          </div>
                          <v-sheet
                            v-for="key in sshKeys"
                            :key="key.name"
                            class="ssh-key-item"
                            color="transparent"
                            elevation="0"
                          >
                            <div class="ssh-key-header">
                              <div class="font-weight-medium">{{ key.name }}</div>
                              <v-chip size="x-small" label>{{ key.type }}</v-chip>
                              <v-chip v-if="key.fingerprint" size="x-small" variant="tonal">
                                {{ key.fingerprint }}
                              </v-chip>
                              <v-spacer />
                              <v-btn
                                variant="text"
                                size="small"
                                prepend-icon="mdi-content-copy"
                                @click="copyToClipboard(key.public_key)"
                              >
                                Copy
                              </v-btn>
                            </div>
                            <pre class="ssh-key-text">{{ key.public_key }}</pre>
                          </v-sheet>
                        </div>
                      </v-card-text>
                      <v-divider />
                      <div class="human-tasks-panel" data-tour-id="tour-human-tasks">
                        <div class="human-tasks-panel__header">
                          <span class="human-tasks-panel__header-title">Human Tasks</span>
                          <div class="human-tasks-panel__badges">
                            <v-chip label size="small" variant="tonal" color="warning">
                              Blocking {{ blockingHumanTaskCount }}
                            </v-chip>
                            <v-chip label size="small" variant="tonal" color="primary">
                              Open {{ openHumanTaskCount }}
                            </v-chip>
                            <v-btn
                              icon="mdi-refresh"
                              size="small"
                              variant="text"
                              :loading="humanTasksLoading"
                              :disabled="humanTasksLoading"
                              @click="refreshHumanTasks"
                              aria-label="Refresh human tasks"
                            ></v-btn>
                          </div>
                        </div>
                        <div class="human-tasks-panel__body">
                          <v-alert
                            v-if="humanTasksError"
                            type="error"
                            variant="tonal"
                            density="comfortable"
                            border="start"
                          >
                            {{ humanTasksError }}
                          </v-alert>
                          <v-skeleton-loader
                            v-else-if="humanTasksLoading && !humanTaskEntries.length"
                            type="list-item@2"
                          />
                          <div v-else-if="humanTaskEntries.length" class="human-tasks-list">
                            <div v-for="task in humanTaskEntries" :key="task.task_id" class="human-task-entry">
                              <div class="human-task-entry__header">
                                <span>{{ task.title }}</span>
                                <span class="text-caption text-medium-emphasis">
                                  {{ task.statusDisplay }}
                                </span>
                              </div>
                              <div class="human-task-entry__meta">
                                <span>{{ task.projectDisplay }}</span>
                                <span v-if="task.prompt_id">Prompt #{{ task.prompt_id }}</span>
                                <span>{{ formatTimestamp(task.updated_at) }}</span>
                              </div>
                              <p class="human-task-entry__description">
                                {{ task.descriptionSnippet }}
                              </p>
                              <div class="human-task-entry__footer">
                                <span>Created {{ formatTimestamp(task.created_at) }}</span>
                                <v-chip
                                  v-if="task.blocking"
                                  size="x-small"
                                  color="error"
                                  variant="tonal"
                                  label
                                >
                                  Blocking
                                </v-chip>
                              </div>
                            </div>
                          </div>
                          <div
                            v-else
                            class="human-tasks-panel__empty"
                          >
                            No human tasks logged yet â€” use scripts/human_tasks.py to add blockers.
                          </div>
                        </div>
                        <div class="human-tasks-panel__footer">
                          Logged blockers keep operators in the loop. Use <code>scripts/human_tasks.py</code> to add or resolve items.
                        </div>
                      </div>
                    </v-card>
                  </v-col>
                  <v-col cols="12" md="7" lg="8">
                    <v-card elevation="0" class="panel-card log-card settings-log-card">
                      <v-card-title class="log-card__header">
                        <div>
                          <div class="text-h6">Operations Log</div>
                          <div class="text-caption text-medium-emphasis">
                            {{ logLastUpdated ? 'Updated Â· ' + formatTimestamp(logLastUpdated) : 'Not refreshed yet' }}
                          </div>
                        </div>
                        <div class="log-card__actions">
                          <v-btn
                            icon="mdi-refresh"
                            variant="text"
                            :loading="logLoading"
                            :disabled="logLoading"
                            @click="refreshProgressLog"
                            aria-label="Refresh operations log"
                          ></v-btn>
                        </div>
                      </v-card-title>
                      <v-divider />
                      <v-card-text class="log-card__body">
                        <v-alert
                          v-if="logError"
                          type="error"
                          variant="tonal"
                          density="comfortable"
                          border="start"
                          class="mb-3"
                        >
                          {{ logError }}
                        </v-alert>
                        <v-skeleton-loader v-if="logLoading && !operationsLog" type="paragraph@3" />
                        <div v-else class="log-content" :class="{ 'log-content--empty': !operationsLog }">
                          <pre v-if="operationsLog">{{ operationsLog }}</pre>
                          <span v-else class="log-content__placeholder">
                            No entries in progress log yet.
                          </span>
                        </div>
                      </v-card-text>
                    </v-card>
                  </v-col>
                </v-row>
              </v-container>
              <v-container v-else class="py-6 main-layout" fluid>
                <v-row class="main-row">
                  <v-col
                    v-if="!isMobileLayout || activeMobilePanel === 'queue'"
                    cols="12"
                    md="4"
                    class="d-flex flex-column"
                  >
                    <v-card elevation="0" class="panel-card queue-card">
                      <v-card-title class="queue-card-title">
                        <span>Task Queue</span>
                        <v-spacer />
                        <v-chip
                          class="realtime-chip"
                          size="small"
                          label
                          :color="wsStatus === 'open' ? 'success' : wsStatus === 'connecting' ? 'warning' : 'error'"
                          variant="tonal"
                        >
                          Realtime Â· {{ formatStatus(wsStatus) }}
                        </v-chip>
                      </v-card-title>
                      <v-divider />
                      <div v-if="isMobileLayout" class="mobile-panel-controls">
                        <v-btn
                          variant="tonal"
                          size="small"
                          prepend-icon="mdi-forum"
                          :disabled="!selectedPrompt"
                          @click="showThreadPanel"
                        >
                          View task thread
                        </v-btn>
                      </div>
                      <div class="project-selector" data-tour-id="tour-project-selector">
                        <v-select
                          v-model="selectedProjectId"
                          :items="projectOptions"
                          item-title="name"
                          item-value="id"
                          label="Project"
                          variant="outlined"
                          density="comfortable"
                          hide-details="auto"
                          :disabled="!projectOptions.length"
                        />
                        <div class="project-selector__hint">
                          <a
                            v-if="activeProjectLaunchUrl"
                            class="project-selector__live-link"
                            :href="activeProjectLaunchUrl"
                            target="_blank"
                            rel="noopener noreferrer"
                          >
                            <span>{{ activeProjectLaunchUrl }}</span>
                            <span class="mdi mdi-open-in-new" aria-hidden="true"></span>
                          </a>
                          <span
                            v-else
                            class="project-selector__live-link project-selector__live-link--disabled"
                          >
                            Live endpoint not configured
                          </span>
                        </div>
                      </div>
                      <v-divider />
                      <div class="queue-composer" data-tour-id="tour-prompt-composer">
                        <v-textarea
                          v-model="promptText"
                          placeholder="Type your next instruction to Codex"
                          variant="outlined"
                          auto-grow
                          rows="3"
                          hide-details
                          @keydown.enter="handleComposerKeydown"
                        />
                        <div class="composer-actions">
                          <div class="text-caption text-medium-emphasis average-prompt-time" v-if="health">
                            <span>Average prompt time</span>
                            <span class="average-prompt-time__value">{{ averagePromptDurationDisplay }}</span>
                          </div>
                          <v-btn
                            color="primary"
                            :loading="submitting"
                            :disabled="!promptText.trim()"
                            @click="submitPrompt"
                          >
                            Send
                          </v-btn>
                        </div>
                      </div>
                      <v-divider />
                      <v-card-text class="queue-scroll" data-tour-id="tour-queue-list">
                        <v-skeleton-loader v-if="loading" type="list-item@4" />
                        <div v-else class="queue-list">
                          <button
                            v-for="entry in queueEntries"
                            :key="entry.prompt_id"
                            type="button"
                            class="queue-entry"
                            :class="{ active: selectedPrompt && selectedPrompt.prompt_id === entry.prompt_id }"
                            @click="selectPrompt(entry)"
                          >
                            <div class="queue-entry-header">
                              <span class="queue-entry-index">#{{ entry.queueIndex }}</span>
                              <span
                                class="queue-entry-status"
                                :class="'status-' + ((entry.status || '').toLowerCase())"
                              >
                                {{ formatStatus(entry.status) }}
                              </span>
                              <span class="queue-entry-created">{{ entry.createdDisplay }}</span>
                              <span class="queue-entry-runtime">Time {{ entry.runtimeDisplay || 'â€”' }}</span>
                            </div>
                            <div class="queue-entry-detail">
                              {{ entry.detailLine }}
                            </div>
                          </button>
                          <div v-if="!queueEntries.length" class="text-center text-medium-emphasis py-6">
                            No prompts yet â€” type a prompt above.
                          </div>
                        </div>
                      </v-card-text>
                    </v-card>
                  </v-col>
                  <v-col
                    v-if="!isMobileLayout || activeMobilePanel === 'thread'"
                    cols="12"
                    md="8"
                    class="d-flex flex-column"
                  >
                    <v-card elevation="0" class="panel-card chat-card" data-tour-id="tour-thread-panel">
                      <v-card-title class="chat-card__header justify-space-between align-start">
                        <div class="chat-card__header-main">
                          <div class="mobile-thread-nav" v-if="isMobileLayout">
                            <v-btn
                              class="mobile-thread-back"
                              variant="text"
                              density="comfortable"
                              prepend-icon="mdi-arrow-left"
                              @click="showQueuePanel"
                            >
                              Back to queue
                            </v-btn>
                          </div>
                          <div
                            class="chat-card-title__heading"
                            v-if="selectedPrompt"
                          >
                            <div class="chat-card-title__task">
                              <button
                                type="button"
                                class="task-id-button"
                                title="Copy task ID"
                                @click.stop="copyToClipboard(selectedPrompt.prompt_id || '')"
                              >
                                Task {{ selectedPrompt.prompt_id }}
                                <span class="mdi mdi-content-copy" aria-hidden="true"></span>
                              </button>
                              <v-btn
                                v-if="canCancelSelectedPrompt"
                                class="chat-card-title__cancel"
                                :color="(selectedPrompt?.status || '').toLowerCase() === 'queued' ? 'error' : 'warning'"
                                variant="outlined"
                                size="small"
                                :loading="canceling"
                                :disabled="canceling"
                                @click="cancelSelectedPrompt"
                              >
                                Cancel
                              </v-btn>
                            </div>
                            <span
                              v-if="selectedPromptProjectName"
                              class="prompt-project-pill"
                            >
                              Project Â· {{ selectedPromptProjectName }}
                            </span>
                          </div>
                          <div
                            class="chat-card-title__heading"
                            v-else
                          >
                            <span
                              v-if="selectedPromptProjectName"
                              class="prompt-project-pill"
                            >
                              Project Â· {{ selectedPromptProjectName }}
                            </span>
                          </div>
                          <div class="text-caption text-medium-emphasis chat-card-subtitle" v-if="selectedPrompt">
                            <span class="chat-card-subtitle__attempts">
                              Attempts {{ selectedPrompt.attempts || 0 }}
                            </span>
                          </div>
                          <div class="text-caption text-medium-emphasis" v-else>
                            Select a prompt from the queue to review Codex output.
                          </div>
                        </div>
                        <div class="thread-header__actions">
                          <v-btn
                            v-if="canRestartSelectedPrompt"
                            color="warning"
                            variant="tonal"
                            size="small"
                            :loading="restarting"
                            :disabled="restarting"
                            @click="restartSelectedPrompt"
                          >
                            Restart
                          </v-btn>
                          <v-btn
                            v-if="selectedPrompt && selectedPrompt.status === 'failed'"
                            color="warning"
                            variant="tonal"
                            size="small"
                            :loading="retrying"
                            @click="retryPrompt"
                          >
                            Retry
                          </v-btn>
                        </div>
                      </v-card-title>
                      <v-divider />
                      <div ref="chatThreadRef" class="chat-thread">
                        <div v-if="!selectedPrompt" class="text-medium-emphasis text-center py-10">
                          Waiting for a prompt selection...
                        </div>
                        <template v-else>
                          <div class="chat-message user">
                            <div class="message-meta message-meta--header">
                              <span>Your prompt</span>
                              <span v-if="selectedPrompt.created_at">
                                Submitted Â· {{ formatTimestamp(selectedPrompt.created_at) }}
                              </span>
                            </div>
                            <details class="detail-panel">
                              <summary>
                                <span>Context</span>
                                <button
                                  type="button"
                                  class="copy-button"
                                  aria-label="Copy context"
                                  title="Copy context"
                                  @click.stop.prevent="copyToClipboard(globalContext || '')"
                                >
                                  <span class="mdi mdi-content-copy" aria-hidden="true"></span>
                                </button>
                              </summary>
                              <div class="detail-content context-block">
                                {{ globalContext || 'No context recorded for this prompt.' }}
                              </div>
                            </details>
                            <div class="chat-bubble prompt copyable">
                              <div class="prompt-bubble-actions">
                                <button
                                  type="button"
                                  class="copy-button"
                                  aria-label="Copy prompt text"
                                  title="Copy prompt text"
                                  @click.stop="copyToClipboard(selectedPrompt.text || '')"
                                >
                                  <span class="mdi mdi-content-copy" aria-hidden="true"></span>
                                </button>
                                <button
                                  v-if="canEditSelectedPrompt"
                                  type="button"
                                  class="copy-button prompt-edit-button"
                                  aria-label="Edit queued prompt"
                                  title="Edit queued prompt"
                                  @click.stop="openEditPromptDialog"
                                >
                                  <span class="mdi mdi-pencil" aria-hidden="true"></span>
                                </button>
                              </div>
                              <div class="prompt-text">
                                {{ selectedPrompt.text || 'Prompt text unavailable.' }}
                              </div>
                            </div>
                          </div>
                          <div v-if="showLiveStream">
                            <div class="chat-message codex">
                              <div class="message-meta message-meta--header">
                                <span>Attempt {{ liveAttemptNumber || 'Live' }}</span>
                                <span>Status Â· {{ formatStatus(selectedPrompt.status) }}</span>
                                <span v-if="liveAttemptReceivedAt">
                                  Received Â· {{ formatTimestamp(liveAttemptReceivedAt) }}
                                </span>
                                <span v-if="liveAttemptDurationSeconds != null">
                                  Time Â· {{ formatDuration(liveAttemptDurationSeconds) }}
                                </span>
                              </div>
                              <details v-if="activeStream.stderr" class="detail-panel" open>
                                <summary>
                                  <span>Output</span>
                                  <button
                                    type="button"
                                    class="copy-button"
                                    aria-label="Copy live stderr"
                                    title="Copy live stderr"
                                    @click.stop.prevent="copyToClipboard(activeStream.stderr || '')"
                                  >
                                    <span class="mdi mdi-content-copy" aria-hidden="true"></span>
                                  </button>
                                </summary>
                                <div class="detail-content stderr-block" ref="liveStreamScrollRef">
                                  <template v-for="(segment, segIndex) in parseOutputSegments(activeStream.stderr)">
                                    <div
                                      v-if="segment.type === 'text'"
                                      class="stderr-segment"
                                      :key="'live-stderr-' + segIndex"
                                    >
                                      {{ segment.content }}
                                    </div>
                                    <details
                                      v-else-if="segment.type === 'code'"
                                      class="stderr-code-block"
                                      :key="'live-stderr-code-' + segIndex"
                                    >
                                      <summary class="stderr-code-summary">
                                        <span class="stderr-code-summary__label">
                                          {{ segment.language ? segment.language + ' Code' : 'Code block' }}
                                        </span>
                                        <span class="stderr-code-summary__preview">
                                          {{ segment.preview }}
                                        </span>
                                      </summary>
                                      <pre class="stderr-code-content">{{ segment.content }}</pre>
                                    </details>
                                    <details
                                      v-else-if="segment.type === 'exec' || segment.type === 'file-update'"
                                      class="stderr-exec-block"
                                      :key="'live-stderr-collapse-' + segment.type + '-' + segIndex"
                                    >
                                      <summary class="stderr-code-summary">
                                        <span class="stderr-code-summary__label">
                                          {{ segment.type === 'file-update' ? 'File update' : 'Command output' }}
                                        </span>
                                        <span class="stderr-code-summary__preview">
                                          {{ segment.preview }}
                                        </span>
                                      </summary>
                                      <pre class="stderr-code-content">{{ segment.content }}</pre>
                                    </details>
                                  </template>
                                </div>
                              </details>
                            </div>
                          </div>
                          <div v-if="attemptLogs.length">
                            <div
                              v-for="(attempt, index) in attemptLogs"
                              :key="attemptKey(attempt, index)"
                              class="attempt-entry"
                            >
                              <div class="chat-message codex">
                                <div class="message-meta message-meta--header">
                                  <span>Attempt {{ index + 1 }}</span>
                                  <span>Status Â· {{ formatStatus(attempt.status || selectedPrompt.status) }}</span>
                                  <span>
                                    Received Â· {{ formatTimestamp(attempt.received_at || selectedPrompt.created_at) }}
                                  </span>
                                  <span>Time Â· {{ formatDuration(attempt.duration_seconds) }}</span>
                                </div>
                                <details v-if="attempt.stderr" class="detail-panel">
                                  <summary>
                                    <span>Output</span>
                                    <button
                                      type="button"
                                      class="copy-button"
                                      aria-label="Copy output"
                                      title="Copy output"
                                      @click.stop.prevent="copyToClipboard(attempt.stderr || '')"
                                    >
                                      <span class="mdi mdi-content-copy" aria-hidden="true"></span>
                                    </button>
                                  </summary>
                                  <div class="detail-content stderr-block">
                                    <template v-for="(segment, segIndex) in parseOutputSegments(attempt.stderr)">
                                      <div
                                        v-if="segment.type === 'text'"
                                        class="stderr-segment"
                                        :key="attemptKey(attempt, index) + '-stderr-text-' + segIndex"
                                      >
                                        {{ segment.content }}
                                      </div>
                                      <details
                                        v-else-if="segment.type === 'code'"
                                        class="stderr-code-block"
                                        :key="attemptKey(attempt, index) + '-stderr-code-' + segIndex"
                                      >
                                        <summary class="stderr-code-summary">
                                          <span class="stderr-code-summary__label">
                                            {{ segment.language ? segment.language + ' Code' : 'Code block' }}
                                          </span>
                                          <span class="stderr-code-summary__preview">
                                            {{ segment.preview }}
                                          </span>
                                        </summary>
                                        <pre class="stderr-code-content">{{ segment.content }}</pre>
                                      </details>
                                    <details
                                      v-else-if="segment.type === 'exec' || segment.type === 'file-update'"
                                      class="stderr-exec-block"
                                      :key="attemptKey(attempt, index) + '-stderr-collapse-' + segment.type + '-' + segIndex"
                                    >
                                      <summary class="stderr-code-summary">
                                        <span class="stderr-code-summary__label">
                                          {{ segment.type === 'file-update' ? 'File update' : 'Command output' }}
                                        </span>
                                        <span class="stderr-code-summary__preview">
                                          {{ segment.preview }}
                                        </span>
                                      </summary>
                                      <pre class="stderr-code-content">{{ segment.content }}</pre>
                                      </details>
                                    </template>
                                  </div>
                                </details>
                                <div class="chat-bubble response copyable">
                                  <button
                                    type="button"
                                    class="copy-button copy-button--floating"
                                    aria-label="Copy reply body"
                                    title="Copy reply body"
                                    @click.stop="copyToClipboard(attempt.stdout || attempt.summary || '')"
                                  >
                                    <span class="mdi mdi-content-copy" aria-hidden="true"></span>
                                  </button>
                                  <div :class="['stdout-block', { 'stdout-empty': !attempt.stdout }]">
                                    {{ attempt.stdout || attempt.summary || 'No stdout recorded yet.' }}
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                          <div v-else-if="!showLiveStream" class="text-medium-emphasis text-center py-10">
                            No Codex output captured for this prompt yet.
                          </div>
                        </template>
                      </div>
                      <div v-if="selectedPrompt" class="detail-footer">
                        <span>Created {{ formatDate(selectedPrompt.created_at) }}</span>
                        <span>Updated {{ formatDate(selectedPrompt.updated_at) }}</span>
                        <span>Status {{ selectedPrompt.status }}</span>
                      </div>
                    </v-card>
                  </v-col>
                </v-row>
              </v-container>
            </v-main>
            <router-view style="display: none;"></router-view>
            <div
              v-if="guidedTourVisible"
              class="guided-tour-overlay"
              role="dialog"
              aria-modal="true"
              aria-label="Guided tour"
            >
              <div class="guided-tour-highlight" :style="guidedTourHighlightStyle" aria-hidden="true"></div>
              <div class="guided-tour-tooltip">
                <span class="guided-tour-step-label">
                  Step {{ guidedTourStepNumber }} of {{ guidedTourTotalSteps }}
                </span>
                <h3>{{ guidedTourCurrentStep ? guidedTourCurrentStep.title : '' }}</h3>
                <p>{{ guidedTourCurrentStep ? guidedTourCurrentStep.description : '' }}</p>
                <p v-if="guidedTourTargetMissing" class="guided-tour-missing">
                  Can't locate this panel? Make sure the dashboard is visible on a larger screen.
                </p>
                <div class="guided-tour-actions">
                  <button type="button" class="guided-tour-link" @click="closeGuidedTour">Skip</button>
                  <div class="guided-tour-actions__spacer"></div>
                  <button
                    type="button"
                    class="guided-tour-button"
                    :disabled="guidedTourStepNumber === 1"
                    @click="previousGuidedTourStep"
                  >
                    Back
                  </button>
                  <button
                    type="button"
                    class="guided-tour-button guided-tour-button--primary"
                    @click="advanceGuidedTour"
                  >
                    {{ isGuidedTourLastStep ? 'Finish tour' : 'Next' }}
                  </button>
                </div>
              </div>
            </div>
          </v-app>
        `,
      })
        .use(vuetify)
        .use(appRouter)
        .mount('#app');
    </script>
  </body>
</html>
